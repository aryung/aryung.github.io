<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | AC分享小站</title><meta name=keywords content><meta name=description content="Posts - AC分享小站"><meta name=author content><link rel=canonical href=https://aryung.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><link rel=icon href=https://aryung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aryung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aryung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aryung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aryung.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://aryung.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WWZN99CL5W"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WWZN99CL5W",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://aryung.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aryung.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aryung.github.io/ accesskey=h title="AC分享小站 (Alt + H)">AC分享小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>what is monad by Haskell</h2></header><div class=entry-content><p>楔子 Monad 是一個數學特性，來看看純的 Haskell 語言怎看待，使用「除法」來做一個簡單的示範說明。
Monads 這是一個 Haskell 基本的語法，宣告一個 Expre 的格式，他有可能是 Int (Val type) ，也有可能是 Div
data Expr = Val Int | Div Expr Expr eval :: Expr -> Int eval (Val n) = n eval (Div x y) = eval x `div` eval y eval (Div (Val 1) (Val 0)) safediv :: Int -> Int -> Maybe Int safediv _ 0 = Nothing safediv n m = Just (n ‘div‘ m) eval :: Expr -> Maybe Int eval (Val n) = Just n eval (Div x y) = case eval x of Nothing -> Nothing Just n -> case eval y of Nothing -> Nothing Just m -> safediv n m eval :: Expr -> Maybe Int eval (Val n) = pure n eval (Div x y) = pure safediv &lt;*> eval x &lt;*> eval y (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b mx >>= f = case mx of Nothing -> Nothing Just x -> f x eval :: Expr -> Maybe Int eval (Val n) = Just n eval (Div x y) = eval x >>= \n -> eval y >>= \m -> safediv n m m1 >>= \x1 -> m2 >>= \x2 -> ....</p></div><footer class=entry-footer><span title="2022-05-26 18:29:06 +0800 +0800">May 26, 2022</span></footer><a class=entry-link aria-label="post link to what is monad by Haskell" href=https://aryung.github.io/posts/what-is-monad-by-haskell/></a></article><article class=post-entry><header class=entry-header><h2>useContext Provider Consumer</h2></header><div class=entry-content><p>楔子 context 就語意上指的就是一個「環境」的概念，就如果轉成電腦來說就是「State」的意思。
而在 react component 有幾種情況可以夾帶這些「環境變數」
props state React 提供了另一個手法「context」來簡化語法
The Context API const LocaleContext = React.createContext(); LocaleContext 有二個屬性: Provider & Consumer
Provider allows us to “declare the data that we want available throughout our component tree”.
Consumer allows “any component in the component tree that needs that data to be able to subscribe to it”.
Provider 提供一個 value 的 props
&lt;MyContext.Provider value={data}> &lt;App /> &lt;/MyContext....</p></div><footer class=entry-footer><span title="2022-05-23 18:29:06 +0800 +0800">May 23, 2022</span></footer><a class=entry-link aria-label="post link to useContext Provider Consumer" href=https://aryung.github.io/posts/2022-05-23-usecontext-provider-consumer/></a></article><article class=post-entry><header class=entry-header><h2>Arrow function generic types</h2></header><div class=entry-content><p>楔子 Arrow Function 很常使用，但它的 Generic Type 有點不太好記，列舉一下幾種
Generic Arrow Functions 正常的函數 Generice Type 的格式
function firstOrNull&lt;T>(arr: T[]): T | null { return arr.length === 0 ? null : arr[0]; } General const firstOrNull = &lt;T>( arr: T[] ): T | null => arr.length === 0 ? null : arr[0]; Extends trick const firstOrNull = &lt;T extends unknown>( arr: T[] ): T | null => arr.length === 0 ?...</p></div><footer class=entry-footer><span title="2022-05-22 09:30:06 +0800 +0800">May 22, 2022</span></footer><a class=entry-link aria-label="post link to Arrow function generic types" href=https://aryung.github.io/posts/2022-05-22-arrow-function-generic-types/></a></article><article class=post-entry><header class=entry-header><h2>Lambda Calculus</h2></header><div class=entry-content><p>楔子 這是一個在計算機歷史用數學演化的方式，具有代表性的規律。
Lambda (λ) Calculus Function Abstraction 能夠用簡單的方式來呈現函數
λx.x^2 + 1
用 js 來表示
let res = x => x * x + 1 Function Application 何謂 β-reduction(beta reduction) ? 就是把「值」代入取得最後的計算結果
let res = (x => x * x + 1)(3) 但有些情況不符合 curry 的表示法
λxy.x*y
就應該轉換成
(λx.(λy.x*y))
但其實 ( ) 是可以被簡化的
λx.λy.x*y
如果先代入一個數值 5
(λx.(λy.x*y)) (5) = (λy.5*y)
再代入 7
(λy.5*y)(7) = 35
用 javascript 來表示
function product(x, y) { return x * y; } product(5, 7) //retuns 35 // curry function product (x) { return function (y) { return x * y; } } 參考資料...</p></div><footer class=entry-footer><span title="2022-05-21 09:30:06 +0800 +0800">May 21, 2022</span></footer><a class=entry-link aria-label="post link to Lambda Calculus" href=https://aryung.github.io/posts/2022-05-21-lambda-calculus/></a></article><article class=post-entry><header class=entry-header><h2>寫給想跳坑的 JS 新手(Part II): coding style</h2></header><div class=entry-content><p>楔子 上一篇提到了 map filter reduce，這三個是最常見的也是最常用的使用方法，為了讓「程式碼」易讀，可以改造一下長相方便讓人看的懂在做什麼，至於怎做的就交給專業的人去優化改善就好。
所以先至少讓別人看的懂自已在寫的東西優先，試想看看，如果你是看 code 的人，「看的懂」vs 「要花一點點時間去細看」這二種，哪一種比較好讀? 先做到至少菜端出來看起來想吃，至於好不好吃就再說囉。嘿嘿嘿
程式碼的味道 用個最簡單的例子，把一個數字 x3 之後再 +1，但當數字是 5時就返回原值
f(1) = 1 * 3 + 1
f(5) = 5 來寫出這個 f 但我們用不同的長相來看看
撒尿牛丸全部攪在一起 這個應該是大部份的程式羅輯，就是把資料拆開來一個一個處理。
function f(x) { if(x !== 5) { return 3 * x + 1 } else { return x } } 點點點到天邊 這個 coding-style 就像你打開一個箱子把東西拿出來，「動作」後再放回去，依序處理。
let box = x => ({f: f => box(f(x)), x}) box(1) .f(multi3) .f(add1) // {f: ƒ f(), x: 4} box(5) ....</p></div><footer class=entry-footer><span title="2022-05-20 09:30:06 +0800 +0800">May 20, 2022</span></footer><a class=entry-link aria-label="post link to 寫給想跳坑的 JS 新手(Part II): coding style" href=https://aryung.github.io/posts/2022-05-20-javascript-newbie-part-ii/></a></article><article class=post-entry><header class=entry-header><h2>寫給想跳坑的 JS 新手(Part I): map filter reduce</h2></header><div class=entry-content><p>楔子 身邊有些朋友有不少會想試著寫寫程式，常常坊間書翻一翻看到物件的東西，很快的就把書放下了，慢慢的也就失去興趣了。
但其實怎讓這些朋友開始可以有些動手做也能跑出一些結果，那種成就感會讓人慢慢的親近寫程式(coding)，不可否認物件導向語言統治了軟體界，但光要先學會這個觀念可能就讓人却步了。
以前有部電影「張三峰」有句台詞，怎「張無忌」問，怎學會這部武功?「張三峰」說:「忘掉就好了」。
其實函數式語言的「入門」蠻簡單的，就像小時候的數學，函數吃一些變數，跑出來一個結果，用這個方式寫寫東西就可以做一些小實務的作品，也很有成就感。
就讓我們試試吧..
Declarative 宣告式 vs. Imperative 命令式 命令式(Imperative)白話文就是要用電腦的角度去思考，怎把答案做出來。
如果相要把一連串的資料去掉一些特定值(前提條件就要知道何謂 for-loop)，示範的程式碼大概會長成下面的樣子
function filter(array) { let newArray = [] for (let index = 0; index &lt; array.length; index++) { const element = array[index] if (element !== null && element !== undefined) { newArray[newArray.length] = element } } return newArray } // use case: filter([0, 1, undefined, 2, null, 3, 'four', '']) // [0, 1, 2, 3, 'four', ''] 但如果是所謂的宣告(Declarative)式，就是使用 filter 函數(知道 map/filter/reduce....</p></div><footer class=entry-footer><span title="2022-05-19 09:30:06 +0800 +0800">May 19, 2022</span></footer><a class=entry-link aria-label="post link to 寫給想跳坑的 JS 新手(Part I): map filter reduce" href=https://aryung.github.io/posts/2022-05-19-javascript-functional-programming-newbie-i/></a></article><article class=post-entry><header class=entry-header><h2>Monad Compose</h2></header><div class=entry-content><p>楔子 今天再來進階一下改寫 Monad compose
Monad 特徵 of: a => M(a) 也有人叫 lift 或 type lift map: map 的 f :: a => M(b) 會變成 M(M(b)) flatten: M(M(b)) => M(b) Monad 有 flapMap 的概念
flatMap = Map + flatten : f(a).flatMap(g) => M(b) const MyMonad = value => ({ flatMap: f => f(value), map (f) { return this.flatMap(a => Monad.of(f(a))), }, }) Monad.of = x => Monad(x) Monad(21)....</p></div><footer class=entry-footer><span title="2022-05-18 09:30:06 +0800 +0800">May 18, 2022</span></footer><a class=entry-link aria-label="post link to Monad Compose" href=https://aryung.github.io/posts/2022-05-18-monad-compose/></a></article><article class=post-entry><header class=entry-header><h2>Monad vs Promise</h2></header><div class=entry-content><p>楔子 來試著說明何謂 monad 這其實是數學的一個名稱，但撇開那些艱深的道理，試試來用 Promise 的例子來說明看看。
Function Compose 最原始的 compose 的觀念就是把多個 function 做組合
const x = 20 const f = n => n * 2 const arr = Array.of(x) const result = arr.map(f) 例如 echo 就是吃二個參數回傳一個 function
const echo = n => x => Array.from({length: n}).fill(x) console.log( [1,2,3].map( echo(3) ) ) 例如 flatMap 就是吃二個參數回傳一個 function
const flatMap = (f, arr) => [].concat(...arr.map(f)) const echo = n => x => Array....</p></div><footer class=entry-footer><span title="2022-05-17 09:30:06 +0800 +0800">May 17, 2022</span></footer><a class=entry-link aria-label="post link to Monad vs Promise" href=https://aryung.github.io/posts/2022-05-17-monad-meet-promise/></a></article><article class=post-entry><header class=entry-header><h2>lens laws</h2></header><div class=entry-content><p>楔子 在 functional programming 中要進行對 store 的設定時，可以用 lens 的方式來進行設定，如果就像一個吸管直接定位來改變值，進行值也可以用函數來取代。
lens laws laws
view(lens, set(lens, store, a)) = a 如果你改變了 store 某個值之後再立刻利用 lens 來取 store 的值，二個會相等(白話的意思就是你改變了 store 的值再拿出來看就是那個值) set(lens, b, set(lens, store, a)) = set(lens, b, store) 如果你改變了 store 的值為 a 又立馬改變值為 b，等同於直接改變值為 b(白話的意思就是你把一個值設了二次，最後的結果是第二次的值) set(lens, view(lens, store), store) = store 如果你用 lens 拿了某個值出來再同時 set 在 store 的 lens 位置的值，store 和原來的一致(白話文就是你取個 lens 的值拿出來的值再設到同一個 lens，該 store 維持不變) const view = (lens, store) => lens....</p></div><footer class=entry-footer><span title="2022-05-15 09:30:06 +0800 +0800">May 15, 2022</span></footer><a class=entry-link aria-label="post link to lens laws" href=https://aryung.github.io/posts/2022-05-15-lens-laws/></a></article><article class=post-entry><header class=entry-header><h2>function mixins</h2></header><div class=entry-content><p>楔子 在公司的專案開發中，程式總會愈長愈大，會慢慢的到了一個程度難以理解，在開發的過程中也慢慢開始把程式做一些模組化的動作。
在程式的抽像化過程中，應該有二大派系很當使用，就是物件導向 & 函數式編程。通常會蠻常出現二個關鍵字
繼承(inheritance) 組合(composition) Mixins “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software”
有一種說法所謂的 mixins 就是像冰淇淋甜筒一樣，想吃什麼挖什麼口味，只要甜筒有那個味道功能，甜筒就只是一個載具而以。
Object composition 在 javascript 內，物件可以塞 function ，這時就要利用到 Object.assign 這個方法。
const chocolate = { hasChocolate: () => true } const caramelSwirl = { hasCaramelSwirl: () => true } const pecans = { hasPecans: () => true } const iceCream = Object....</p></div><footer class=entry-footer><span title="2022-05-13 09:30:06 +0800 +0800">May 13, 2022</span></footer><a class=entry-link aria-label="post link to function mixins" href=https://aryung.github.io/posts/2022-05-13-function-mixins/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://aryung.github.io/posts/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://aryung.github.io/>AC分享小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>