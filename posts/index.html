<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | AC分享小站</title><meta name=keywords content><meta name=description content="Posts - AC分享小站"><meta name=author content><link rel=canonical href=https://aryung.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><link rel=icon href=https://aryung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aryung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aryung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aryung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aryung.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://aryung.github.io/posts/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-WWZN99CL5W"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WWZN99CL5W",{anonymize_ip:!1})}</script><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://aryung.github.io/posts/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aryung.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aryung.github.io/ accesskey=h title="AC分享小站 (Alt + H)">AC分享小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>callback promise async/await</h2></header><div class=entry-content><p>楔子 最近小夥伴問了，React 的 jsx 基本的結構長如何，是如何轉換的之類的，順便記錄一下網路大神的資料摘錄。
React 有一個 createElement 的方法可以把資料轉成 react 特殊的結構 React.createElement('div', props={}) 收到特殊的結構之後再由 ReactDOM.render 來進行放在 html 上的位置 ReactDOM.render(jsDOM, document.getElementById('root')) React Basic React vs ReactDOM 摘錄一些 Kent 的示範 code 來演示一下，element 1 ~ 3 就是各種 jsDOM 的寫法，比較特別的是 React.createElement 可以有 2 ~3 個輸入參數
第一個參數指的是 HTML 的 DOM 種類(eg. div span …) 第二個參數輸入的是該 DOM 的 props 第三個參數輸入的是 children const element1 = React.createElement('div', {className: 'container'}) const element2 = React.createElement('div', {className: 'container'}, 'Hello', '', 'World') const element3 = React....</p></div><footer class=entry-footer><span title="2022-05-09 09:29:06 +0800 +0800">May 9, 2022</span></footer><a class=entry-link aria-label="post link to callback promise async/await" href=https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/></a></article><article class=post-entry><header class=entry-header><h2>callback promise async/await</h2></header><div class=entry-content><p>楔子 同樣的 javascript 針對所謂的 async 有其發生的歷史變革，有興趣的可以去找找影片了解一下。
callback 一開始採用的方式就是使用一個 callback function，因為 javascript 可以把 function 當參數丟入另一個 function，就有了最原始的模式，基本的概念就是
function executeFunc(callbackFun) { // some async function call callbackFun() } 題型: 請使用 setTimeout 來寫一個 1秒後 console.log(100) 的 callback function case // step 1. define function to run function go(){ // step 2. use setTimeout callback function to run after 1 sec setTimeout(()=> { // step 3. write console 100 }, sec) } // step 4....</p></div><footer class=entry-footer><span title="2022-05-04 09:29:06 +0800 +0800">May 4, 2022</span></footer><a class=entry-link aria-label="post link to callback promise async/await" href=https://aryung.github.io/posts/2022-05-04-callback-promise-async-await/></a></article><article class=post-entry><header class=entry-header><h2>Dockerfile 小練習</h2></header><div class=entry-content><p>楔子 Docker 是現在開發的基本工，除了不想污染本地的環境以外，更重要的是可以把執行環境標準化，不會因為不同的環境就有無法執行的狀況，來試著了解一下吧。
網路的 docker 說明介紹蠻多的，就不多做說明了，就比較用講解的方式來自已可以寫一個所屬的 dockerfile 的實做羅輯。
環境架構 自行參考相關安裝
MacOS linux windows 認識 images 與 tag 來試看看 ubuntu 的 base image 來看， (image name):(tag) 這是基本的格式，這個格式可以使用在 dockerfile 內。 ubuntu example
試題來試試 case I Hint: (為 dockerfile 指令)
基礎的影像 base image (FROM)
每個程式都會歷經 build test(optional) runtime 的過程 (RUN CMD)
把原來的程式碼 copy 到 docker 內的 workdir (COPY WORKDIR)
安裝相關程式(dependency) (RUN)
試著寫出一個 NodeApp Dockerfile 提示: 下方為 build & runtime 的 bash 指令...</p></div><footer class=entry-footer><span title="2022-05-02 18:29:06 +0800 +0800">May 2, 2022</span></footer><a class=entry-link aria-label="post link to Dockerfile 小練習" href=https://aryung.github.io/posts/2022-05-02-dockerfile-write/></a></article><article class=post-entry><header class=entry-header><h2>more about prototypes</h2></header><div class=entry-content><p>楔子 原型鏈 (prototype chain) 應該是 javascript 新人入門最討厭的東西了。
在這個語言中其實只有幾大類別(number string boolean)
Undefined (undefined), used for unintentionally missing values. Null (null), used for intentionally missing values. Booleans (true and false), used for logical operations. Numbers (-100, 3.14, and others), used for math calculations. BigInts (uncommon and new), used for math on big numbers. Strings (“hello”, “abracadabra”, and others), used for text. Symbols (uncommon), used to perform rituals and hide secrets. 比較特別的就是 Object 和 Function 了，先摘錄一些網路大神的圖解。...</p></div><footer class=entry-footer><span title="2022-05-01 18:30:06 +0800 +0800">May 1, 2022</span></footer><a class=entry-link aria-label="post link to more about prototypes" href=https://aryung.github.io/posts/2022-05-01-more-about-prototype-chain/></a></article><article class=post-entry><header class=entry-header><h2>composition over inheritance</h2></header><div class=entry-content><p>楔子 如果平常在寫 OOP(物件導向)語言的人，應該就會很熟悉繼承(inheritance);如果有寫 ruby 的人，應該更熟悉鴨子型別(duck typing);如果在寫 FP(functional programming)的，就更熟悉組合(composition)。每個語言都有他的特性，端看怎使用而以，語言的熟悉度就在於這些手法的習性而以。
但在 javascript 中其實都可以實踐這些特性來讓不同的技術人來使用，今天就拿一些網站的 demo code 來分享。
code 先來看看標準的 es2015 的 classes & prototype
Inheritance with Classes
// case I prototype var Animal = function(name) { this.name = name } var Alligator = function(name) { Animal.apply(this, arguments); // Call parent constructor } Alligator.prototype = Object.create(Animal.prototype) Alligator.prototype.constructor = Alligator var jack = new Alligator("jack") // case II classes class Animal { constructor(name) { this....</p></div><footer class=entry-footer><span title="2022-04-29 18:29:06 +0800 +0800">April 29, 2022</span></footer><a class=entry-link aria-label="post link to composition over inheritance" href=https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/></a></article><article class=post-entry><header class=entry-header><h2>kubernetes terraform helm 起手式</h2></header><div class=entry-content><p>楔子 現在雲端化的產品服務這麼多，怎一開始入門來使用這些服務，這次來聊聊這個話題吧。
觀念 主要有幾個東西:
kubernetes:負責 app 的擴展，穩定服務等等 helm:負責產生 kubernetes 的設定參數樣版文件 terraform:負責來設定雲端的資源環境 為了不讓東西討論到細節，就先簡單把 kubernetes 想像成可以使用的程式，而 helm 就想像成去設定程式的一些參數，而 terraform 想像成要用哪些資源。 當然可以去花點時間去官網看看詳細的介紹。
環境 為了在本地端使用開發測試，就本地安裝 minikube 來替代 kubernetes ，再簡化說明， helm 就是這些設定 kubernetes 的相關設定，至於 terraform 就當做設定這些程式所需要的相關資源(eg.多大的 cpu 和 ram)
示範 code 使用 terraform + kubernetes config terraform 要設定幾個東西
kubernetes mysql deployment & mysql service wordpress deployment & wordpress service provider "kubernetes" { config_context = "minikube" } locals { wordpress_labels = { App = "wordpress" Tier = "frontend" } mysql_labels = { App = "wordpress" Tier = "mysql" } } resource "kubernetes_secret" "mysql-pass" { metadata { name = "mysql-pass" } data = { password = "root" } } resource "kubernetes_deployment" "wordpress" { metadata { name = "wordpress" labels = local....</p></div><footer class=entry-footer><span title="2022-04-28 18:29:06 +0800 +0800">April 28, 2022</span></footer><a class=entry-link aria-label="post link to kubernetes terraform helm 起手式" href=https://aryung.github.io/posts/2022-04-28-kubernetes-terraform-helm/></a></article><article class=post-entry><header class=entry-header><h2>useContext Provider 起手式</h2></header><div class=entry-content><p>楔子 useContext 是 hook 系列很常使用的東西，通常就在「跨」 components 之間使用，有時加減也好用也有點濫用，說說比較常使用的情境吧..
例如像 Global Theme 在所有的 component 都包上一層，像 Material UI 就採用這種模式..
那像假設 firebase Oauth 的情況時，要用嗎?還是可以用 custom hook?其實這二種方式都有人用，看自已的習慣而以..
一般式 這是比較正常的方式，最外層包一個 Provider 再利用 render prop 來操作
import React from 'react'; export const UserContext = React.createContext(); export default function App() { return ( &lt;UserContext.Provider value="user"> &lt;User /> &lt;/UserContext.Provider> ) } function User() { return ( &lt;UserContext.Consumer> {value => &lt;h1>{value}&lt;/h1>} &lt;/UserContext.Consumer> ) } Kent c dodds 但其實如果使用 Kent 的起手式，其實蠻優美的.. Kent useContext code...</p></div><footer class=entry-footer><span title="2022-04-08 18:29:06 +0800 +0800">April 8, 2022</span></footer><a class=entry-link aria-label="post link to useContext Provider 起手式" href=https://aryung.github.io/posts/2022-04-08-hook-context-provider/></a></article><article class=post-entry><header class=entry-header><h2>JS 大魔王 this</h2></header><div class=entry-content><p>楔子 JS 的 this 通常有所謂的 scope 問題，最近蠻常遇到小夥伴在問，就順便做一下整理，而且通常this會和class一起出現使用。
this 單獨使用 大概有幾種情況
默認綁定(default binding) 在 function 內的 this 為 function 上一層，strict模式為 undefined function main(){ console.log(this) // this = global } main() 隱式綁定(implicit binding) var person = { name: 'ac', getName: function() { console.log(this) // this = person } } person.getName() // 'ac' function click(cb){ cb() } var name = 'aac' click(person.getName) // 把 person.getName 丟到 click 的參數時 // 這時的 this = global，這時 global....</p></div><footer class=entry-footer><span title="2022-03-30 18:29:06 +0800 +0800">March 30, 2022</span></footer><a class=entry-link aria-label="post link to JS 大魔王 this" href=https://aryung.github.io/posts/2022-03-30-this/></a></article><article class=post-entry><header class=entry-header><h2>JS 其實不是 class 的好朋友</h2></header><div class=entry-content><p>楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應，有趣的現象是在 js 環境下，後端很常用 OOP: class style.
但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下， 就可能要去準備一下 class style 的 JS/Node。
而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。
tl;dr
一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。
不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，反而會比較有感就感。當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..實務上的差異並不太大，踩到坑再去記住會身體更有感覺。
通常 this 會和 class 一起使用，而其實this就把它當成context(環境參數)來看待就可以了。
Object.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method
var objTemplate = {name: 'yo'} var childObj = Object....</p></div><footer class=entry-footer><span title="2022-03-27 18:29:06 +0800 +0800">March 27, 2022</span></footer><a class=entry-link aria-label="post link to JS 其實不是 class 的好朋友" href=https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/></a></article><article class=post-entry><header class=entry-header><h2>GraphQL Server 方案</h2></header><div class=entry-content><p>楔子 GraphQL Server 的基本架構大概就幾個主要的元件:
types 資料結構定義 Server 伺服服務 resolver 資料整理用 模版的東西就拿來改比較快，畢竟自已搞定也要很有愛。
codesandbox
市面上常用的大概就 apollor server，要自已寫 types 和 resolvers。
另一個比較好用的有 prisma ，它本身有包含 database ORM 的功用，
也有自動產出 client 段方便套在自已的前端 web。
雜談 其實在 GraphQL 中，最重要的就是 types & resolvers，
這二個的意函在哪裡? types 其實就想像成資料的欄位設定，
resolvers 就想像成取得資料要進行「加減乘除」等等處理的方法。
如果從架構的角度來看
client(Framework) &lt;-> (server &lt;-> database)
在 client 和 server 端為了要彼此能溝通，勢必就要有一個標準的 types 來做依據。
就指的是 client 和 server 端其實都各自要能吃同樣的 types & 解析 query-languages
在 server 端，就因為常常有舊的資料庫問題，那是不是這個 type 同時也能滿足 ORM 的功能?...</p></div><footer class=entry-footer><span title="2022-03-23 18:29:06 +0800 +0800">March 23, 2022</span></footer><a class=entry-link aria-label="post link to GraphQL Server 方案" href=https://aryung.github.io/posts/2022-03-23-graphql-server/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://aryung.github.io/posts/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://aryung.github.io/>AC分享小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>