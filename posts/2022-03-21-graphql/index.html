<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>graphql use case | AC分享小站</title><meta name=keywords content="javascript"><meta name=description content="楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點，
久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯，
慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件，
但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。
GraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema & 路由 routes)，
這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。
Server 元件 要架一個 GraqphQL Server，思考一下要什麼東西??
就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理
 Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type & schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等)  server var express = require('express'); var { graphqlHTTP } = require('express-graphql'); var { buildSchema } = require('graphql'); var schema = buildSchema(` type Query { hello: String } `); var root = { hello: () => 'Hello world!"><meta name=author content><link rel=canonical href=https://aryung.github.io/posts/2022-03-21-graphql/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://aryung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aryung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aryung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aryung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aryung.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=${G-MEASUREMENT_ID}"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","${G-MEASUREMENT_ID}")</script><meta property="og:title" content="graphql use case"><meta property="og:description" content="楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點，
久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯，
慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件，
但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。
GraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema & 路由 routes)，
這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。
Server 元件 要架一個 GraqphQL Server，思考一下要什麼東西??
就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理
 Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type & schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等)  server var express = require('express'); var { graphqlHTTP } = require('express-graphql'); var { buildSchema } = require('graphql'); var schema = buildSchema(` type Query { hello: String } `); var root = { hello: () => 'Hello world!"><meta property="og:type" content="article"><meta property="og:url" content="https://aryung.github.io/posts/2022-03-21-graphql/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-21T18:29:06+08:00"><meta property="article:modified_time" content="2022-03-21T18:29:06+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="graphql use case"><meta name=twitter:description content="楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點，
久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯，
慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件，
但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。
GraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema & 路由 routes)，
這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。
Server 元件 要架一個 GraqphQL Server，思考一下要什麼東西??
就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理
 Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type & schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等)  server var express = require('express'); var { graphqlHTTP } = require('express-graphql'); var { buildSchema } = require('graphql'); var schema = buildSchema(` type Query { hello: String } `); var root = { hello: () => 'Hello world!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aryung.github.io/posts/"},{"@type":"ListItem","position":2,"name":"graphql use case","item":"https://aryung.github.io/posts/2022-03-21-graphql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"graphql use case","name":"graphql use case","description":"楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點，\n久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯，\n慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件，\n但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。\nGraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema \u0026amp; 路由 routes)，\n這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。\nServer 元件 要架一個 GraqphQL Server，思考一下要什麼東西??\n就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理\n Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type \u0026amp; schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等)  server var express = require(\u0026#39;express\u0026#39;); var { graphqlHTTP } = require(\u0026#39;express-graphql\u0026#39;); var { buildSchema } = require(\u0026#39;graphql\u0026#39;); var schema = buildSchema(` type Query { hello: String } `); var root = { hello: () =\u0026gt; \u0026#39;Hello world!","keywords":["javascript"],"articleBody":"楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點，\n久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯，\n慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件，\n但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。\nGraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema \u0026 路由 routes)，\n這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。\nServer 元件 要架一個 GraqphQL Server，思考一下要什麼東西??\n就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理\n Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type \u0026 schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等)  server var express = require('express'); var { graphqlHTTP } = require('express-graphql'); var { buildSchema } = require('graphql'); var schema = buildSchema(` type Query { hello: String } `); var root = { hello: () = 'Hello world!' }; var app = express(); app.use('/graphql', graphqlHTTP({ schema: schema, rootValue: root, graphiql: true, })); app.listen(4000, () = console.log('Now browse to localhost:4000/graphql')); 定義(Schema) GraphQL 的 schema 定義其實很像 typescript(或許有小夥伴說這是什?以後再做介紹囉)\ntype Character { name: String! appearsIn: [Episode!]! } 查詢語法(Query Language) 有 GUI 的查詢語法\n{ hero { name appearsIn } } 配合查詢語法所用的 resolver(business logic) 類似說，當查詢語法進來時，會有一些變數(ctx, parent…)，這時吃到這些參數時，\n所進行的一連串資料的處理(eg. ORM 拉資料  做處理  吐回資料)\nvar postType = new GraphQLObjectType({ name: ‘Post’, fields: { body: { type: GraphQLString, resolve: (post, args, context, { rootValue }) = { // return the post body only if the user is the post's author if (context.user \u0026\u0026 (context.user.id === post.authorId)) { return post.body; } return null; } } } }); ","wordCount":"210","inLanguage":"en","datePublished":"2022-03-21T18:29:06+08:00","dateModified":"2022-03-21T18:29:06+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aryung.github.io/posts/2022-03-21-graphql/"},"publisher":{"@type":"Organization","name":"AC分享小站","logo":{"@type":"ImageObject","url":"https://aryung.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><script async src="https://www.googletagmanager.com/gtag/js?id=${G-MEASUREMENT_ID}"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","${G-MEASUREMENT_ID}")</script><nav class=nav><div class=logo><a href=https://aryung.github.io/ accesskey=h title="AC分享小站 (Alt + H)">AC分享小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>graphql use case</h1><div class=post-meta><span title="2022-03-21 18:29:06 +0800 +0800">March 21, 2022</span></div></header><div class=post-content><h1 id=楔子>楔子<a hidden class=anchor aria-hidden=true href=#楔子>#</a></h1><p>一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點，</p><p>久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯，</p><p>慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件，</p><p>但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。</p><h1 id=graphql>GraphQL<a hidden class=anchor aria-hidden=true href=#graphql>#</a></h1><p>主要的精神架構為， Server 設定好條件(資料的格式 schema & 路由 routes)，</p><p>這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。</p><h2 id=server-元件>Server 元件<a hidden class=anchor aria-hidden=true href=#server-元件>#</a></h2><p>要架一個 GraqphQL Server，思考一下要什麼東西??</p><p>就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理</p><ul><li>Server: 可以用 ExpressJS，Apollo Server.. <a href=https://graphql.org/code/#javascript>graphQL server</a></li><li>Scehma: 基本上就是一個定義檔，可以用不同語言的格式 <a href=https://graphql.org/learn/schema/#object-types-and-fields>type & schema</a>，應該各語言都有一些轉換方式</li><li>logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. <a href=https://sequelize.org>sequelize</a>, typeorm, prisma..等等)</li></ul><h3 id=server>server<a hidden class=anchor aria-hidden=true href=#server>#</a></h3><pre tabindex=0><code>var express = require(&#39;express&#39;);
var { graphqlHTTP } = require(&#39;express-graphql&#39;);
var { buildSchema } = require(&#39;graphql&#39;);

var schema = buildSchema(`
  type Query {
    hello: String
  }
`);

var root = { hello: () =&gt; &#39;Hello world!&#39; };

var app = express();
app.use(&#39;/graphql&#39;, graphqlHTTP({
  schema: schema,
  rootValue: root,
  graphiql: true,
}));
app.listen(4000, () =&gt; console.log(&#39;Now browse to localhost:4000/graphql&#39;));
</code></pre><h3 id=定義schema>定義(Schema)<a hidden class=anchor aria-hidden=true href=#定義schema>#</a></h3><p>GraphQL 的 schema 定義其實很像 typescript(或許有小夥伴說這是什?以後再做介紹囉)</p><pre tabindex=0><code>type Character {
  name: String!
  appearsIn: [Episode!]!
}
</code></pre><h3 id=查詢語法query-language>查詢語法(Query Language)<a hidden class=anchor aria-hidden=true href=#查詢語法query-language>#</a></h3><p>有 GUI 的查詢語法</p><pre tabindex=0><code>{
  hero {
    name
    appearsIn
  }
}
</code></pre><h3 id=配合查詢語法所用的-resolverbusiness-logic>配合查詢語法所用的 resolver(business logic)<a hidden class=anchor aria-hidden=true href=#配合查詢語法所用的-resolverbusiness-logic>#</a></h3><p>類似說，當查詢語法進來時，會有一些變數(ctx, parent&mldr;)，這時吃到這些參數時，</p><p>所進行的一連串資料的處理(eg. ORM 拉資料 > 做處理 > 吐回資料)</p><pre tabindex=0><code>var postType = new GraphQLObjectType({
  name: ‘Post’,
  fields: {
    body: {
      type: GraphQLString,
      resolve: (post, args, context, { rootValue }) =&gt; {
        // return the post body only if the user is the post&#39;s author
        if (context.user &amp;&amp; (context.user.id === post.authorId)) {
          return post.body;
        }
        return null;
      }
    }
  }
});
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://aryung.github.io/tags/javascript/>javascript</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://aryung.github.io/>AC分享小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>