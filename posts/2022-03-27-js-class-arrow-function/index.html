<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JS 其實不是 class 的好朋友 | AC 技術分享小站</title><meta name=keywords content="javascript"><meta name=description content="楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應。
有趣的現象是在 js 環境下，後端很常用 OOP: class style。
但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。
如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下，
就可能要去準備一下 class style 的 JS/Node。
而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。
tl;dr
一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，
而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，
感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，
而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。
不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，
發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，
反而會比較有感就感。
當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..
實務上的差異並不太大，踩到坑再去記住會身體更有感覺。
Object.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method"><meta name=author content><link rel=canonical href=https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://aryung.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://aryung.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://aryung.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://aryung.github.io/apple-touch-icon.png><link rel=mask-icon href=https://aryung.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JS 其實不是 class 的好朋友"><meta property="og:description" content="楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應。
有趣的現象是在 js 環境下，後端很常用 OOP: class style。
但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。
如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下，
就可能要去準備一下 class style 的 JS/Node。
而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。
tl;dr
一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，
而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，
感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，
而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。
不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，
發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，
反而會比較有感就感。
當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..
實務上的差異並不太大，踩到坑再去記住會身體更有感覺。
Object.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method"><meta property="og:type" content="article"><meta property="og:url" content="https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-27T18:29:06+08:00"><meta property="article:modified_time" content="2022-03-27T18:29:06+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JS 其實不是 class 的好朋友"><meta name=twitter:description content="楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應。
有趣的現象是在 js 環境下，後端很常用 OOP: class style。
但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。
如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下，
就可能要去準備一下 class style 的 JS/Node。
而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。
tl;dr
一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，
而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，
感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，
而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。
不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，
發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，
反而會比較有感就感。
當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..
實務上的差異並不太大，踩到坑再去記住會身體更有感覺。
Object.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://aryung.github.io/posts/"},{"@type":"ListItem","position":2,"name":"JS 其實不是 class 的好朋友","item":"https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JS 其實不是 class 的好朋友","name":"JS 其實不是 class 的好朋友","description":"楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應。\n有趣的現象是在 js 環境下，後端很常用 OOP: class style。\n但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。\n如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下，\n就可能要去準備一下 class style 的 JS/Node。\n而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。\ntl;dr\n一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，\n而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，\n感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，\n而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。\n不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，\n發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，\n反而會比較有感就感。\n當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..\n實務上的差異並不太大，踩到坑再去記住會身體更有感覺。\nObject.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method","keywords":["javascript"],"articleBody":"楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應。\n有趣的現象是在 js 環境下，後端很常用 OOP: class style。\n但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。\n如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下，\n就可能要去準備一下 class style 的 JS/Node。\n而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。\ntl;dr\n一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，\n而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，\n感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，\n而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。\n不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，\n發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，\n反而會比較有感就感。\n當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..\n實務上的差異並不太大，踩到坑再去記住會身體更有感覺。\nObject.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method\nvar objTemplate = {name: 'yo'} var childObj = Object.create(objTemplate) console.log(childObj) // {} why? console.log(childObj.name) // yo why? call apply bind 和 Object.create 有異取同工之妙\n這篇可以參考 pjchender\n// this 指的是 function scope var person = { firstname: 'Jeremy', lastname: 'Lin', getFullName: function(){ var fullname = this.firstname + ' ' + this.lastname; return fullname; } } // this 指是 ? 因為沒有 object 就往上一層 window var logName = function(location1,location2){ console.log('Logged: ' + this.getFullName()); console.log('Arguments: ' + location1 + ' ' + location2); } 有了上面的樣本，開始把 this 用 bind apply call 綁進去取代 this\nvar logName = function(location1,location2){ console.log('Logged: ' + this.getFullName()); console.log('Arguments: ' + location1 + ' ' + location2); }.bind(person) // 重點是取 person 的 this.getFullName() logName('Taiwan', 'Japan') 來看看 call \u0026 apply\nvar logName = function(location1,location2){ console.log('Logged: ' + this.getFullName()); console.log('Arguments: ' + location1 + ' ' + location2); } // call logName.call(person, 'Taiwan', 'Japan') var logName = function(location1,location2){ console.log('Logged: ' + this.getFullName()); console.log('Arguments: ' + location1 + ' ' + location2); } // apply logName.apply(person, ['Taiwan', 'Japan']) function add(a, b) { return (this.age ? 0 : 10) + a + b } add.call({age: 10}, 1, 2) // 13 add.call(null, 1, 4) // 5 add.apply(null, [1, 2]) // 3 add.apply(null, [1, 4]) // 5 var add1 = add.bind(null, 1); console.log(add1(2)) // 3 console.log(add1(4))\tFunction 採用 Function style 來建立一些 OOP style 的感覺\nfunction Person(name){ this.name = name this.getName = () = this.name getNameWithoutThis = () = this.name //? } var yo = new Person('yo') yo.getNameWithThis() // yo class base class class Person { constructor(name) { this.name = name; } getName() { return this.name } } var yo = new Person('yo'); console.log(yo) extends class Person { constructor(name) { this.name = name; } getName() { return this.name } } // 使用 extends class Friend extends Person { constructor(name, age) { // 用 super 呼叫 extends 指定的 class super(name); this.age = age; } getAge() { return this.age } } const ho = new Friend('ho', 18); console.log(ho.getName()); // ho console.log(ho.getAge()); // 18 arrow function vs function (this) 箭頭函數的 this 取最近一層的 scope，所以在 function 內的 this 的 scope 在 function，而 setTimeout 的 scope 會取最大層(window)\nlet id = 21; let data = { id: 21, }; fn.call(data); arrowFn.call(data); // 原本的 function function fn() { console.log(this.constructor.name); // Object(data) setTimeout(function () { console.log(this.constructor.name); // Window }, 100); } // 箭頭函式 Arrow function function arrowFn() { console.log(this.constructor.name); // Object(data) setTimeout(() = { console.log(this.constructor.name); // Object(data) }, 100); } 這時的 arrowFn 指的是 window\nvar button = document.querySelector('button') var arrowFn = () = { // 建立 function 時 this 指 Window console.log(this.constructor.name) // 執行 function 時 this 指 Window } var fn = function () { // 建立 function 時 this 指 Window console.log(this.constructor.name) // 執行 function 時 this 指 HTMLButtonElement } button.addEventListener('click', arrowFn) ","wordCount":"517","inLanguage":"en","datePublished":"2022-03-27T18:29:06+08:00","dateModified":"2022-03-27T18:29:06+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/"},"publisher":{"@type":"Organization","name":"AC 技術分享小站","logo":{"@type":"ImageObject","url":"https://aryung.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aryung.github.io/ accesskey=h title="AC 技術分享小站 (Alt + H)">AC 技術分享小站</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>JS 其實不是 class 的好朋友</h1><div class=post-meta><span title="2022-03-27 18:29:06 +0800 +0800">March 27, 2022</span></div></header><div class=post-content><h1 id=楔子>楔子<a hidden class=anchor aria-hidden=true href=#楔子>#</a></h1><p>Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應。</p><p>有趣的現象是在 js 環境下，後端很常用 OOP: class style。</p><p>但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。</p><p>如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下，</p><p>就可能要去準備一下 class style 的 JS/Node。</p><p>而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。</p><p>tl;dr</p><p>一開始入門 js 時，光搞懂這些 <code>this</code> <code>class</code> 的東西應該就飽了，</p><p>而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，</p><p>感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，</p><p>而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。</p><p>不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，</p><p>發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，</p><p>反而會比較有感就感。</p><p>當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..</p><p>實務上的差異並不太大，踩到坑再去記住會身體更有感覺。</p><h2 id=objectcreate>Object.create<a hidden class=anchor aria-hidden=true href=#objectcreate>#</a></h2><p><code>Object.create</code> 就是建立一個 Object 的模版資料，會依 <code>prototype chian</code> 去尋找相關的 method</p><pre tabindex=0><code>var objTemplate = {name: &#39;yo&#39;}
var childObj = Object.create(objTemplate)
console.log(childObj) // {} why?
console.log(childObj.name) // yo why?
</code></pre><h2 id=call-apply-bind>call apply bind<a hidden class=anchor aria-hidden=true href=#call-apply-bind>#</a></h2><p>和 <code>Object.create</code> 有異取同工之妙</p><p>這篇可以參考 <a href=https://pjchender.blogspot.com/2016/06/function-borrowingfunction-currying.html>pjchender</a></p><pre tabindex=0><code>// this 指的是 function scope
var person = {
  firstname: &#39;Jeremy&#39;,
  lastname: &#39;Lin&#39;,
  getFullName: function(){
    var fullname = this.firstname + &#39; &#39; + this.lastname;
    return fullname;
  }
}

// this 指是 ? 因為沒有 object 就往上一層 window
var logName = function(location1,location2){
  console.log(&#39;Logged: &#39; + this.getFullName());
  console.log(&#39;Arguments: &#39; + location1 + &#39; &#39; + location2);
}
</code></pre><p>有了上面的樣本，開始把 this 用 <code>bind</code> <code>apply</code> <code>call</code> 綁進去取代 <code>this</code></p><pre tabindex=0><code>var logName = function(location1,location2){
  console.log(&#39;Logged: &#39; + this.getFullName());
  console.log(&#39;Arguments: &#39; + location1 + &#39; &#39; + location2);
}.bind(person) // 重點是取 person 的 this.getFullName()

logName(&#39;Taiwan&#39;, &#39;Japan&#39;)
</code></pre><p>來看看 call & apply</p><pre tabindex=0><code>var logName = function(location1,location2){
  console.log(&#39;Logged: &#39; + this.getFullName());
  console.log(&#39;Arguments: &#39; + location1 + &#39; &#39; + location2);
}
// call
logName.call(person, &#39;Taiwan&#39;, &#39;Japan&#39;)

var logName = function(location1,location2){
  console.log(&#39;Logged: &#39; + this.getFullName());
  console.log(&#39;Arguments: &#39; + location1 + &#39; &#39; + location2);
}
// apply
logName.apply(person, [&#39;Taiwan&#39;, &#39;Japan&#39;])
</code></pre><pre tabindex=0><code>function add(a, b) {
  return (this.age ? 0 : 10) + a + b
}
add.call({age: 10}, 1, 2) // 13
add.call(null, 1, 4) // 5 
add.apply(null, [1, 2]) // 3
add.apply(null, [1, 4]) // 5
var add1 = add.bind(null, 1);
console.log(add1(2)) // 3
console.log(add1(4))	
</code></pre><h2 id=function>Function<a hidden class=anchor aria-hidden=true href=#function>#</a></h2><p>採用 Function style 來建立一些 OOP style 的感覺</p><pre tabindex=0><code>function Person(name){
  this.name = name
  this.getName = () =&gt; this.name
  getNameWithoutThis = () =&gt; this.name //?
}

var yo = new Person(&#39;yo&#39;)
yo.getNameWithThis() // yo
</code></pre><h2 id=class>class<a hidden class=anchor aria-hidden=true href=#class>#</a></h2><h3 id=base-class>base class<a hidden class=anchor aria-hidden=true href=#base-class>#</a></h3><pre tabindex=0><code>class Person {
  constructor(name) {
    this.name = name;
  }
  
  getName() {
    return this.name
  }
}

var yo = new Person(&#39;yo&#39;);
console.log(yo)
</code></pre><h3 id=extends>extends<a hidden class=anchor aria-hidden=true href=#extends>#</a></h3><pre tabindex=0><code>class Person {
  constructor(name) {
    this.name = name;
  }
  
  getName() {
    return this.name
  }
}

// 使用 extends 
class Friend extends Person {
  constructor(name, age) {
    // 用 super 呼叫 extends 指定的 class
    super(name);
    this.age = age;
  }
  
  getAge() {
    return this.age
  }
}

const ho = new Friend(&#39;ho&#39;, 18);

console.log(ho.getName()); // ho
console.log(ho.getAge()); // 18
</code></pre><h3 id=arrow-function-vs-function-this>arrow function vs function (this)<a hidden class=anchor aria-hidden=true href=#arrow-function-vs-function-this>#</a></h3><p>箭頭函數的 this 取最近一層的 scope，所以在 function 內的 this 的 scope 在 function，而 setTimeout 的 scope 會取最大層(window)</p><pre tabindex=0><code>let id = 21;
let data = {
  id: 21,
};

fn.call(data);
arrowFn.call(data);

// 原本的 function
function fn() {
  console.log(this.constructor.name); // Object(data)

  setTimeout(function () {
    console.log(this.constructor.name); // Window
  }, 100);
}

// 箭頭函式 Arrow function
function arrowFn() {
  console.log(this.constructor.name); // Object(data)

  setTimeout(() =&gt; {
    console.log(this.constructor.name); // Object(data)
  }, 100);
}
</code></pre><p>這時的 arrowFn 指的是 window</p><pre tabindex=0><code>var button = document.querySelector(&#39;button&#39;)
var arrowFn = () =&gt; {
  // 建立 function 時 this 指 Window
  console.log(this.constructor.name) // 執行 function 時 this 指 Window
}
var fn = function () {
  // 建立 function 時 this 指 Window
  console.log(this.constructor.name) // 執行 function 時 this 指 HTMLButtonElement
}

button.addEventListener(&#39;click&#39;, arrowFn)
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://aryung.github.io/tags/javascript/>javascript</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://aryung.github.io/>AC 技術分享小站</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>