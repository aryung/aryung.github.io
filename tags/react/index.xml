<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>react on AC分享小站</title><link>https://aryung.github.io/tags/react/</link><description>Recent content in react on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Tue, 10 May 2022 09:30:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/react/index.xml" rel="self" type="application/rss+xml"/><item><title>react rule of hook</title><link>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</link><pubDate>Tue, 10 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</guid><description>楔子 React 改成 functional component 最方便用的方式，在整個 code syntax 也是簡潔，不過當新舊交換時，常常難免會有一些使用上的規範。
rule of hook 直接用 Tyler 的範例來標示 rule
function Counter () { // 👍 from the top level function component const [count, setCount] = React.useState(0) if (count % 2 === 0) { // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } const handleIncrement = () =&amp;gt; { setCount((c) =&amp;gt; c + 1) // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } } function useAuthed() { // 👍 from the top level of a custom Hook const [authed, setAuthed] = React.</description></item><item><title>React.createElement vs ReactDOM.render</title><link>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</link><pubDate>Mon, 09 May 2022 09:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</guid><description>楔子 最近小夥伴問了，React 的 jsx 基本的結構長如何，是如何轉換的之類的，順便記錄一下網路大神的資料摘錄。
React 有一個 createElement 的方法可以把資料轉成 react 特殊的結構 React.createElement('div', props={}) 收到特殊的結構之後再由 ReactDOM.render 來進行放在 html 上的位置 ReactDOM.render(jsDOM, document.getElementById('root')) React Basic React vs ReactDOM 摘錄一些 Kent 的示範 code 來演示一下，element 1 ~ 3 就是各種 jsDOM 的寫法，比較特別的是 React.createElement 可以有 2 ~3 個輸入參數
第一個參數指的是 HTML 的 DOM 種類(eg. div span &amp;hellip;) 第二個參數輸入的是該 DOM 的 props 第三個參數輸入的是 children const element1 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}) const element2 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}, &amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;World&amp;#39;) const element3 = React.</description></item><item><title>useContext Provider 起手式</title><link>https://aryung.github.io/posts/2022-04-08-hook-context-provider/</link><pubDate>Fri, 08 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-08-hook-context-provider/</guid><description>楔子 useContext 是 hook 系列很常使用的東西，通常就在「跨」 components 之間使用，有時加減也好用也有點濫用，說說比較常使用的情境吧..
例如像 Global Theme 在所有的 component 都包上一層，像 Material UI 就採用這種模式..
那像假設 firebase Oauth 的情況時，要用嗎?還是可以用 custom hook?其實這二種方式都有人用，看自已的習慣而以..
一般式 這是比較正常的方式，最外層包一個 Provider 再利用 render prop 來操作
import React from &amp;#39;react&amp;#39;; export const UserContext = React.createContext(); export default function App() { return ( &amp;lt;UserContext.Provider value=&amp;#34;user&amp;#34;&amp;gt; &amp;lt;User /&amp;gt; &amp;lt;/UserContext.Provider&amp;gt; ) } function User() { return ( &amp;lt;UserContext.Consumer&amp;gt; {value =&amp;gt; &amp;lt;h1&amp;gt;{value}&amp;lt;/h1&amp;gt;} &amp;lt;/UserContext.</description></item><item><title>Promise 新手常花時間的坑</title><link>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</link><pubDate>Sun, 13 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</guid><description>楔子 最近有些小夥伴在彼此討論時，常常出現一些不太知道原因，但改一改就好了，就隨手做一下筆記也方便提醒自已。
狀況一: 分不清楚有沒有回傳值 functo go1 () { return 1 } // 有回傳值 functin go2 () { console.log(3) } // 無回傳值 const go3 = () =&amp;gt; 2 const go4 = () =&amp;gt; { console.log(4) } // 無回傳值 function addOne (x) { return x } const go5 = () =&amp;gt; addOne(3) const go6 = () =&amp;gt; { 7 } const go7 = (x) =&amp;gt; ({x}) 從上面的問題來看，最直覺的就是要有 return 字眼就是代表有回傳值，所以 go1 go2 很容易判斷。</description></item><item><title>React 設計模式: Compound Components</title><link>https://aryung.github.io/posts/2022-03-10-react-patten-compond-component/</link><pubDate>Thu, 10 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-10-react-patten-compond-component/</guid><description>楔子 摘錄 Kent 的 React Advance Pattern: Compond Components
這個設計模式有什特殊的點?
如果要做一個切換的鈕的元件，大概就會用一個變數來判斷要如何切換?
function App() { const [on, setOn] = React.useState(false) return ( &amp;lt;div&amp;gt; { on ? &amp;lt;div&amp;gt;The button is on&amp;lt;/div&amp;gt; : null } { on ? null : &amp;lt;div&amp;gt;The button is off&amp;lt;/div&amp;gt; } &amp;lt;/div&amp;gt; ) } 這樣的 code 就有點醜，那有沒有可能性把 code 長成這樣 ?
function App() { return ( &amp;lt;div&amp;gt; &amp;lt;Toggle&amp;gt; &amp;lt;ToggleOn&amp;gt;The button is on&amp;lt;/ToggleOn&amp;gt; &amp;lt;ToggleOff&amp;gt;The button is off&amp;lt;/ToggleOff&amp;gt; &amp;lt;ToggleButton /&amp;gt; &amp;lt;/Toggle&amp;gt; &amp;lt;/div&amp;gt; ) } 來完成 Toogle ToogleOn ToogleOff 這三個元件的寫法呢?</description></item><item><title>如何在 useEffect 內使用 async function</title><link>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</link><pubDate>Tue, 08 Mar 2022 20:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</guid><description>使用情境 一開始的 API 呼叫把值塞進 React 搜尋 autocomplete 前端一開始開啟都會有呼叫 API 情境的狀況發生，比較基本的方式使用大概會長這樣子。
const Users = () =&amp;gt; { const [users, setUsers] = useState([]) useEffect(() =&amp;gt; { fetchUsers().then((users) =&amp;gt; setUsers(users)) }, []) if (!users) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt; return ( &amp;lt;ul&amp;gt; {users.map((user) =&amp;gt; ( &amp;lt;li&amp;gt;{user.name}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ) } 那如果要使用 async/await 呢?
很直覺的會這樣寫
// 直接在 useEffect 內使用 async useEffect(async () =&amp;gt; { const users = await fetchUsers() setUsers(users) }, []) 但會有一個情況發生，還記的 useEffect 有一個 cleanup function 嗎?</description></item></channel></rss>