<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>javascript on AC分享小站</title><link>https://aryung.github.io/tags/javascript/</link><description>Recent content in javascript on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Thu, 19 May 2022 09:30:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>寫給想跳坑的 JS 新手(Part I): map filter reduce</title><link>https://aryung.github.io/posts/2022-05-19-javascript-functional-programming-newbie-i/</link><pubDate>Thu, 19 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-19-javascript-functional-programming-newbie-i/</guid><description>楔子 身邊有些朋友有不少會想試著寫寫程式，常常坊間書翻一翻看到物件的東西，很快的就把書放下了，慢慢的也就失去興趣了。
但其實怎讓這些朋友開始可以有些動手做也能跑出一些結果，那種成就感會讓人慢慢的親近寫程式(coding)，不可否認物件導向語言統治了軟體界，但光要先學會這個觀念可能就讓人却步了。
以前有部電影「張三峰」有句台詞，怎「張無忌」問，怎學會這部武功?「張三峰」說:「忘掉就好了」。
其實函數式語言的「入門」蠻簡單的，就像小時候的數學，函數吃一些變數，跑出來一個結果，用這個方式寫寫東西就可以做一些小實務的作品，也很有成就感。
就讓我們試試吧..
Declarative 宣告式 vs. Imperative 命令式 命令式(Imperative)白話文就是要用電腦的角度去思考，怎把答案做出來。
如果相要把一連串的資料去掉一些特定值(前提條件就要知道何謂 for-loop)，示範的程式碼大概會長成下面的樣子
function filter(array) { let newArray = [] for (let index = 0; index &amp;lt; array.length; index++) { const element = array[index] if (element !== null &amp;amp;&amp;amp; element !== undefined) { newArray[newArray.length] = element } } return newArray } // use case: filter([0, 1, undefined, 2, null, 3, &amp;#39;four&amp;#39;, &amp;#39;&amp;#39;]) // [0, 1, 2, 3, &amp;#39;four&amp;#39;, &amp;#39;&amp;#39;] 但如果是所謂的宣告(Declarative)式，就是使用 filter 函數(知道 map/filter/reduce.</description></item><item><title>Monad Compose</title><link>https://aryung.github.io/posts/2022-05-18-monad-compose/</link><pubDate>Wed, 18 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-18-monad-compose/</guid><description>楔子 今天再來進階一下改寫 Monad compose
Monad 特徵 of: a =&amp;gt; M(a) 也有人叫 lift 或 type lift map: map 的 f :: a =&amp;gt; M(b) 會變成 M(M(b)) flatten: M(M(b)) =&amp;gt; M(b) Monad 有 flapMap 的概念
flatMap = Map + flatten : f(a).flatMap(g) =&amp;gt; M(b) const MyMonad = value =&amp;gt; ({ flatMap: f =&amp;gt; f(value), map (f) { return this.flatMap(a =&amp;gt; Monad.of(f(a))), }, }) Monad.of = x =&amp;gt; Monad(x) Monad(21).</description></item><item><title>Monad vs Promise</title><link>https://aryung.github.io/posts/2022-05-17-monad-meet-promise/</link><pubDate>Tue, 17 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-17-monad-meet-promise/</guid><description>楔子 來試著說明何謂 monad 這其實是數學的一個名稱，但撇開那些艱深的道理，試試來用 Promise 的例子來說明看看。
Function Compose 最原始的 compose 的觀念就是把多個 function 做組合
const x = 20 const f = n =&amp;gt; n * 2 const arr = Array.of(x) const result = arr.map(f) 例如 echo 就是吃二個參數回傳一個 function
const echo = n =&amp;gt; x =&amp;gt; Array.from({length: n}).fill(x) console.log( [1,2,3].map( echo(3) ) ) 例如 flatMap 就是吃二個參數回傳一個 function
const flatMap = (f, arr) =&amp;gt; [].concat(...arr.map(f)) const echo = n =&amp;gt; x =&amp;gt; Array.</description></item><item><title>lens laws</title><link>https://aryung.github.io/posts/2022-05-15-lens-laws/</link><pubDate>Sun, 15 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-15-lens-laws/</guid><description>楔子 在 functional programming 中要進行對 store 的設定時，可以用 lens 的方式來進行設定，如果就像一個吸管直接定位來改變值，進行值也可以用函數來取代。
lens laws laws
view(lens, set(lens, store, a)) = a 如果你改變了 store 某個值之後再立刻利用 lens 來取 store 的值，二個會相等(白話的意思就是你改變了 store 的值再拿出來看就是那個值) set(lens, b, set(lens, store, a)) = set(lens, b, store) 如果你改變了 store 的值為 a 又立馬改變值為 b，等同於直接改變值為 b(白話的意思就是你把一個值設了二次，最後的結果是第二次的值) set(lens, view(lens, store), store) = store 如果你用 lens 拿了某個值出來再同時 set 在 store 的 lens 位置的值，store 和原來的一致(白話文就是你取個 lens 的值拿出來的值再設到同一個 lens，該 store 維持不變) const view = (lens, store) =&amp;gt; lens.</description></item><item><title>function mixins</title><link>https://aryung.github.io/posts/2022-05-13-function-mixins/</link><pubDate>Fri, 13 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-13-function-mixins/</guid><description>楔子 在公司的專案開發中，程式總會愈長愈大，會慢慢的到了一個程度難以理解，在開發的過程中也慢慢開始把程式做一些模組化的動作。
在程式的抽像化過程中，應該有二大派系很當使用，就是物件導向 &amp;amp; 函數式編程。通常會蠻常出現二個關鍵字
繼承(inheritance) 組合(composition) Mixins “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software”
有一種說法所謂的 mixins 就是像冰淇淋甜筒一樣，想吃什麼挖什麼口味，只要甜筒有那個味道功能，甜筒就只是一個載具而以。
Object composition 在 javascript 內，物件可以塞 function ，這時就要利用到 Object.assign 這個方法。
const chocolate = { hasChocolate: () =&amp;gt; true } const caramelSwirl = { hasCaramelSwirl: () =&amp;gt; true } const pecans = { hasPecans: () =&amp;gt; true } const iceCream = Object.</description></item><item><title>react rule of hook</title><link>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</link><pubDate>Tue, 10 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</guid><description>楔子 React 改成 functional component 最方便用的方式，在整個 code syntax 也是簡潔，不過當新舊交換時，常常難免會有一些使用上的規範。
rule of hook 直接用 Tyler 的範例來標示 rule
function Counter () { // 👍 from the top level function component const [count, setCount] = React.useState(0) if (count % 2 === 0) { // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } const handleIncrement = () =&amp;gt; { setCount((c) =&amp;gt; c + 1) // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } } function useAuthed() { // 👍 from the top level of a custom Hook const [authed, setAuthed] = React.</description></item><item><title>React.createElement vs ReactDOM.render</title><link>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</link><pubDate>Mon, 09 May 2022 09:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</guid><description>楔子 最近小夥伴問了，React 的 jsx 基本的結構長如何，是如何轉換的之類的，順便記錄一下網路大神的資料摘錄。
React 有一個 createElement 的方法可以把資料轉成 react 特殊的結構 React.createElement('div', props={}) 收到特殊的結構之後再由 ReactDOM.render 來進行放在 html 上的位置 ReactDOM.render(jsDOM, document.getElementById('root')) React Basic React vs ReactDOM 摘錄一些 Kent 的示範 code 來演示一下，element 1 ~ 3 就是各種 jsDOM 的寫法，比較特別的是 React.createElement 可以有 2 ~3 個輸入參數
第一個參數指的是 HTML 的 DOM 種類(eg. div span &amp;hellip;) 第二個參數輸入的是該 DOM 的 props 第三個參數輸入的是 children const element1 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}) const element2 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}, &amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;World&amp;#39;) const element3 = React.</description></item><item><title>callback promise async/await</title><link>https://aryung.github.io/posts/2022-05-04-callback-promise-async-await/</link><pubDate>Wed, 04 May 2022 09:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-04-callback-promise-async-await/</guid><description>楔子 同樣的 javascript 針對所謂的 async 有其發生的歷史變革，有興趣的可以去找找影片了解一下。
callback 一開始採用的方式就是使用一個 callback function，因為 javascript 可以把 function 當參數丟入另一個 function，就有了最原始的模式，基本的概念就是
function executeFunc(callbackFun) { // some async function call callbackFun() } 題型: 請使用 setTimeout 來寫一個 1秒後 console.log(100) 的 callback function case // step 1. define function to run function go(){ // step 2. use setTimeout callback function to run after 1 sec setTimeout(()=&amp;gt; { // step 3. write console 100 }, sec) } // step 4.</description></item><item><title>JS 大魔王 this</title><link>https://aryung.github.io/posts/2022-03-30-this/</link><pubDate>Wed, 30 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-30-this/</guid><description>楔子 JS 的 this 通常有所謂的 scope 問題，最近蠻常遇到小夥伴在問，就順便做一下整理，而且通常this會和class一起出現使用。
this 單獨使用 大概有幾種情況
默認綁定(default binding) 在 function 內的 this 為 function 上一層，strict模式為 undefined function main(){ console.log(this) // this = global } main() 隱式綁定(implicit binding) var person = { name: &amp;#39;ac&amp;#39;, getName: function() { console.log(this) // this = person } } person.getName() // &amp;#39;ac&amp;#39; function click(cb){ cb() } var name = &amp;#39;aac&amp;#39; click(person.getName) // 把 person.getName 丟到 click 的參數時 // 這時的 this = global，這時 global.</description></item><item><title>JS 其實不是 class 的好朋友</title><link>https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/</link><pubDate>Sun, 27 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/</guid><description>楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應，有趣的現象是在 js 環境下，後端很常用 OOP: class style.
但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下， 就可能要去準備一下 class style 的 JS/Node。
而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。
tl;dr
一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。
不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，反而會比較有感就感。當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..實務上的差異並不太大，踩到坑再去記住會身體更有感覺。
通常 this 會和 class 一起使用，而其實this就把它當成context(環境參數)來看待就可以了。
Object.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method
var objTemplate = {name: &amp;#39;yo&amp;#39;} var childObj = Object.</description></item><item><title>GraphQL Server 方案</title><link>https://aryung.github.io/posts/2022-03-23-graphql-server/</link><pubDate>Wed, 23 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-23-graphql-server/</guid><description>楔子 GraphQL Server 的基本架構大概就幾個主要的元件:
types 資料結構定義 Server 伺服服務 resolver 資料整理用 模版的東西就拿來改比較快，畢竟自已搞定也要很有愛。
codesandbox
市面上常用的大概就 apollor server，要自已寫 types 和 resolvers。
另一個比較好用的有 prisma ，它本身有包含 database ORM 的功用，
也有自動產出 client 段方便套在自已的前端 web。
雜談 其實在 GraphQL 中，最重要的就是 types &amp;amp; resolvers，
這二個的意函在哪裡? types 其實就想像成資料的欄位設定，
resolvers 就想像成取得資料要進行「加減乘除」等等處理的方法。
如果從架構的角度來看
client(Framework) &amp;lt;-&amp;gt; (server &amp;lt;-&amp;gt; database)
在 client 和 server 端為了要彼此能溝通，勢必就要有一個標準的 types 來做依據。
就指的是 client 和 server 端其實都各自要能吃同樣的 types &amp;amp; 解析 query-languages
在 server 端，就因為常常有舊的資料庫問題，那是不是這個 type 同時也能滿足 ORM 的功能?</description></item><item><title>graphql use case</title><link>https://aryung.github.io/posts/2022-03-21-graphql-intro/</link><pubDate>Mon, 21 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-21-graphql-intro/</guid><description>楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點， 久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯， 慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件， 但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。
GraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema &amp;amp; 路由 routes)，
這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。
Server 元件 要架一個 GraphQL Server，思考一下要什麼東西??
就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理
Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type &amp;amp; schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等) server var express = require(&amp;#39;express&amp;#39;) var { graphqlHTTP } = require(&amp;#39;express-graphql&amp;#39;) var { buildSchema } = require(&amp;#39;graphql&amp;#39;) var schema = buildSchema(` type Query { hello: String } `) var root = { hello: () =&amp;gt; &amp;#39;Hello world!</description></item><item><title>如何使用 try catch</title><link>https://aryung.github.io/posts/2022-03-18-fp-trycatch/</link><pubDate>Fri, 18 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-18-fp-trycatch/</guid><description>楔子 寫程式時噴錯誤是蠻常見的，就每發生一個錯誤，再加一個條件去排除錯誤的問題
往往如此， code 就會開始蠻的有點「巢狀」的感覺
if(check) { // 1-level if(check) { // 2-level if(check) { // 3-level } else { // 3-level } } else { // 2-level } } else { // 1-level } 原來的 try-catch 標準的 try-catch 程式長相大概如下， try-catch 主要的功用就是避免程式噴錯跳離
try { // do something } catch (e) { console.log(e.message) } 但也常常有個問題就是錯誤的類型如果不確定，就常常一直補 code 除錯。
所以常常的流程大概就是
包一個 try-catch ，噴錯看 log ，補 if-else 的 bug handling，再重覆 try-catch 的 log..
// version 1 function go(x) { try { let len = x.</description></item><item><title>Box 的好用之處</title><link>https://aryung.github.io/posts/2022-03-15-fp-box/</link><pubDate>Tue, 15 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-15-fp-box/</guid><description>楔子 程式碼是拿來使用的，今天就來分享一些小工具來幫助寫 code ，這些東西算是函數式編程的入門吧，用久了才會比較有感，今天就當來練練手。
先上個常用的 tool box
const pipe = (...fns) =&amp;gt; x =&amp;gt; fns.reduce((y, f) =&amp;gt; f(y), x) const I = x =&amp;gt; x const Box = x =&amp;gt; ({ chain: f =&amp;gt; f(x), map: f =&amp;gt; Box(f(x)), fold: f =&amp;gt; f(x), inspect: () =&amp;gt; `Box(${x})` }) const Right = x =&amp;gt; ({ chain : f =&amp;gt; f(x), map : f =&amp;gt; Right(f(x)), fold : (f, g) =&amp;gt; g(x), inspect : () =&amp;gt; `Right(${x})` }) const Left = x =&amp;gt; ({ chain : f =&amp;gt; Left(x), map : f =&amp;gt; Left(x), fold : (f, g) =&amp;gt; f(x), inspect : () =&amp;gt; `Left(${x})` }) const fromNullable = x =&amp;gt; (x === null || x === undefined || x.</description></item><item><title>Promise 新手常花時間的坑</title><link>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</link><pubDate>Sun, 13 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</guid><description>楔子 最近有些小夥伴在彼此討論時，常常出現一些不太知道原因，但改一改就好了，就隨手做一下筆記也方便提醒自已。
狀況一: 分不清楚有沒有回傳值 functo go1 () { return 1 } // 有回傳值 functin go2 () { console.log(3) } // 無回傳值 const go3 = () =&amp;gt; 2 const go4 = () =&amp;gt; { console.log(4) } // 無回傳值 function addOne (x) { return x } const go5 = () =&amp;gt; addOne(3) const go6 = () =&amp;gt; { 7 } const go7 = (x) =&amp;gt; ({x}) 從上面的問題來看，最直覺的就是要有 return 字眼就是代表有回傳值，所以 go1 go2 很容易判斷。</description></item><item><title>JS Prototype by Tyler McGinnis</title><link>https://aryung.github.io/posts/2022-03-08-uidot-prototype/</link><pubDate>Tue, 08 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-uidot-prototype/</guid><description>楔子 Tyler 講的 prototype 的觀念蠻清楚 &amp;amp; 簡單的，稍做一下記錄 Tyler McGinnis javascript
prototype Prototype is a property of a function that point to an object when function is created.
用下面的例子就可以來解釋上面的句子
function imAFunction () {} imAFunction.prototype // {constructor: f} 把共用的 Method 放在一起包裝在一個 Object 內
// 共用的 method const animalMethods() { eat () {}, sleep () {}, play () {} } function Animal (name, energy) { let animal = Object.crete(animalMethods) animal.name = name animal.</description></item><item><title>如何在 useEffect 內使用 async function</title><link>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</link><pubDate>Tue, 08 Mar 2022 20:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</guid><description>使用情境 一開始的 API 呼叫把值塞進 React 搜尋 autocomplete 前端一開始開啟都會有呼叫 API 情境的狀況發生，比較基本的方式使用大概會長這樣子。
const Users = () =&amp;gt; { const [users, setUsers] = useState([]) useEffect(() =&amp;gt; { fetchUsers().then((users) =&amp;gt; setUsers(users)) }, []) if (!users) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt; return ( &amp;lt;ul&amp;gt; {users.map((user) =&amp;gt; ( &amp;lt;li&amp;gt;{user.name}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ) } 那如果要使用 async/await 呢?
很直覺的會這樣寫
// 直接在 useEffect 內使用 async useEffect(async () =&amp;gt; { const users = await fetchUsers() setUsers(users) }, []) 但會有一個情況發生，還記的 useEffect 有一個 cleanup function 嗎?</description></item><item><title>JS 原型說明 by Dan Abramov</title><link>https://aryung.github.io/posts/2022-03-08-justjavascript-prototype/</link><pubDate>Tue, 08 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-justjavascript-prototype/</guid><description>楔子 不同的大神針對 JS 有不同的說明講解，來看一下 Redux 作者的說明。
Dan Abramov 有一個 justjavascrpt prototype 其實把觀念寫的蠻好的。
這篇文章是其中一個 prototype 的內容摘錄如下:
先有一個觀念就是 a = '123' 中 a 是變數(variable)， 123 是值(value)
// teeth 是 variable // 32 是值 let human = { teeth: 32 } let gwen = { age: 19 } human 和 gwen 是一個 Object，他把屬性直接連到 值
// gwen 沒有 teeth 屬性 console.log(gwen.teeth) // undefined let human = { teeth: 32 } 如果當用 __proto__ 在 Object 裡面，=的右邊是一個變數，這是就是去找這個變數的 reference 在哪?</description></item><item><title>函數式編程 Functor 的運用</title><link>https://aryung.github.io/posts/2022-03-04-functional-programming-in-js-box/</link><pubDate>Fri, 04 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-04-functional-programming-in-js-box/</guid><description>特徵 可以把函數當參數使用 可以使用 compose(反向) 或 pipe(正向) 的串連方式 // 建立一個標準的函數 let func = f = x =&amp;gt; f(x) let addOne = x =&amp;gt; x + 1 let ff = func(addOne) // f = addOne ff(1) // 1+1 pipe 就像一個水管一樣串接不同的 function
const pipe = (...fns) =&amp;gt; x =&amp;gt; fns.reduce((y, f) =&amp;gt; f(y), x) pipe(x =&amp;gt; x + 1, x =&amp;gt; x + 2)(3) 練習看看 有了上面的東西，如何使用?
如果有興趣可以去看看 Dr.Boolean 的一些影片，擷取一些常用的工具來做使用。
const pipe = (.</description></item></channel></rss>