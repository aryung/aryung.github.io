<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>oop on AC分享小站</title><link>https://aryung.github.io/tags/oop/</link><description>Recent content in oop on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Fri, 29 Apr 2022 18:29:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/oop/index.xml" rel="self" type="application/rss+xml"/><item><title>composition over inheritance</title><link>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</link><pubDate>Fri, 29 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</guid><description>楔子 如果平常在寫 OOP(物件導向)語言的人，應該就會很熟悉繼承(inheritance);如果有寫 ruby 的人，應該更熟悉鴨子型別(duck typing);如果在寫 FP(functional programming)的，就更熟悉組合(composition)。每個語言都有他的特性，端看怎使用而以，語言的熟悉度就在於這些手法的習性而以。
但在 javascript 中其實都可以實踐這些特性來讓不同的技術人來使用，今天就拿一些網站的 demo code 來分享。
code 先來看看標準的 es2015 的 classes &amp;amp; prototype
Inheritance with Classes
// case I prototype var Animal = function(name) { this.name = name; } var Alligator = function(name) { Animal.apply(this, arguments); // Call parent constructor } Alligator.prototype = Object.create(Animal.prototype); Alligator.prototype.constructor = Alligator; var jack = new Alligator(&amp;#34;jack&amp;#34;); // case II classes class Animal { constructor(name) { this.</description></item></channel></rss>