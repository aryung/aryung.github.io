<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>oop on AC分享小站</title><link>https://aryung.github.io/tags/oop/</link><description>Recent content in oop on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Sun, 01 May 2022 18:30:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/oop/index.xml" rel="self" type="application/rss+xml"/><item><title>more about prototypes</title><link>https://aryung.github.io/posts/2022-05-01-more-about-prototype-chain/</link><pubDate>Sun, 01 May 2022 18:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-01-more-about-prototype-chain/</guid><description>楔子 原型鏈 (prototype chain) 應該是 javascript 新人入門最討厭的東西了。
在這個語言中其實只有幾大類別(number string boolean)
Undefined (undefined), used for unintentionally missing values. Null (null), used for intentionally missing values. Booleans (true and false), used for logical operations. Numbers (-100, 3.14, and others), used for math calculations. BigInts (uncommon and new), used for math on big numbers. Strings (&amp;ldquo;hello&amp;rdquo;, &amp;ldquo;abracadabra&amp;rdquo;, and others), used for text. Symbols (uncommon), used to perform rituals and hide secrets. 比較特別的就是 Object 和 Function 了，先摘錄一些網路大神的圖解。</description></item><item><title>composition over inheritance</title><link>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</link><pubDate>Fri, 29 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</guid><description>楔子 如果平常在寫 OOP(物件導向)語言的人，應該就會很熟悉繼承(inheritance);如果有寫 ruby 的人，應該更熟悉鴨子型別(duck typing);如果在寫 FP(functional programming)的，就更熟悉組合(composition)。每個語言都有他的特性，端看怎使用而以，語言的熟悉度就在於這些手法的習性而以。
但在 javascript 中其實都可以實踐這些特性來讓不同的技術人來使用，今天就拿一些網站的 demo code 來分享。
code 先來看看標準的 es2015 的 classes &amp;amp; prototype
Inheritance with Classes
// case I prototype var Animal = function(name) { this.name = name } var Alligator = function(name) { Animal.apply(this, arguments); // Call parent constructor } Alligator.prototype = Object.create(Animal.prototype) Alligator.prototype.constructor = Alligator var jack = new Alligator(&amp;#34;jack&amp;#34;) // case II classes class Animal { constructor(name) { this.</description></item></channel></rss>