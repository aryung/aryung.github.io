<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>hook on AC分享小站</title><link>https://aryung.github.io/tags/hook/</link><description>Recent content in hook on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Mon, 23 May 2022 18:29:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/hook/index.xml" rel="self" type="application/rss+xml"/><item><title>useContext Provider Consumer</title><link>https://aryung.github.io/posts/2022-05-23-usecontext-provider-consumer/</link><pubDate>Mon, 23 May 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-23-usecontext-provider-consumer/</guid><description>楔子 context 就語意上指的就是一個「環境」的概念，就如果轉成電腦來說就是「State」的意思。
而在 react component 有幾種情況可以夾帶這些「環境變數」
props state React 提供了另一個手法「context」來簡化語法
The Context API const LocaleContext = React.createContext(); LocaleContext 有二個屬性: Provider &amp;amp; Consumer
Provider allows us to &amp;ldquo;declare the data that we want available throughout our component tree&amp;rdquo;.
Consumer allows &amp;ldquo;any component in the component tree that needs that data to be able to subscribe to it&amp;rdquo;.
Provider 提供一個 value 的 props
&amp;lt;MyContext.Provider value={data}&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/MyContext.</description></item><item><title>react rule of hook</title><link>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</link><pubDate>Tue, 10 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</guid><description>楔子 React 改成 functional component 最方便用的方式，在整個 code syntax 也是簡潔，不過當新舊交換時，常常難免會有一些使用上的規範。
rule of hook 直接用 Tyler 的範例來標示 rule
function Counter () { // 👍 from the top level function component const [count, setCount] = React.useState(0) if (count % 2 === 0) { // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } const handleIncrement = () =&amp;gt; { setCount((c) =&amp;gt; c + 1) // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } } function useAuthed() { // 👍 from the top level of a custom Hook const [authed, setAuthed] = React.</description></item><item><title>如何在 useEffect 內使用 async function</title><link>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</link><pubDate>Tue, 08 Mar 2022 20:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</guid><description>使用情境 一開始的 API 呼叫把值塞進 React 搜尋 autocomplete 前端一開始開啟都會有呼叫 API 情境的狀況發生，比較基本的方式使用大概會長這樣子。
const Users = () =&amp;gt; { const [users, setUsers] = useState([]) useEffect(() =&amp;gt; { fetchUsers().then((users) =&amp;gt; setUsers(users)) }, []) if (!users) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt; return ( &amp;lt;ul&amp;gt; {users.map((user) =&amp;gt; ( &amp;lt;li&amp;gt;{user.name}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ) } 那如果要使用 async/await 呢?
很直覺的會這樣寫
// 直接在 useEffect 內使用 async useEffect(async () =&amp;gt; { const users = await fetchUsers() setUsers(users) }, []) 但會有一個情況發生，還記的 useEffect 有一個 cleanup function 嗎?</description></item></channel></rss>