<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>hook on AC分享小站</title><link>https://aryung.github.io/tags/hook/</link><description>Recent content in hook on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Tue, 08 Mar 2022 20:29:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/hook/index.xml" rel="self" type="application/rss+xml"/><item><title>如何在 useEffect 內使用 async function</title><link>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</link><pubDate>Tue, 08 Mar 2022 20:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</guid><description>使用情境 一開始的 API 呼叫把值塞進 React 搜尋 autocomplete 前端一開始開啟都會有呼叫 API 情境的狀況發生，比較基本的方式使用大概會長這樣子。
const Users = () =&amp;gt; { const [users, setUsers] = useState([]) useEffect(() =&amp;gt; { fetchUsers().then((users) =&amp;gt; setUsers(users)) }, []) if (!users) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt; return ( &amp;lt;ul&amp;gt; {users.map((user) =&amp;gt; ( &amp;lt;li&amp;gt;{user.name}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ) } 那如果要使用 async/await 呢?
很直覺的會這樣寫
// 直接在 useEffect 內使用 async useEffect(async () =&amp;gt; { const users = await fetchUsers() setUsers(users) }, []) 但會有一個情況發生，還記的 useEffect 有一個 cleanup function 嗎?</description></item></channel></rss>