<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>演算法 on AC 技術分享小站</title><link>https://aryung.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/</link><description>Recent content in 演算法 on AC 技術分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Wed, 09 Mar 2022 21:29:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/%E6%BC%94%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>取得所有的組合再求結果</title><link>https://aryung.github.io/posts/2022-03-09-combination/</link><pubDate>Wed, 09 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-09-combination/</guid><description>使用情境 資料中任二組(或以上)符合某個條件
例如: 想找 [1,2,3,4,5] 任二個值「大於」3有哪些情況
二組資料的「所有組合」想找符合條件的結果
例如: [1,2,3,4] 和 [7,8.9] 的組合中那個「乘」大於 10
上面的情況在整理資料中蠻常發現的，所以手上有這個函數是蠻方便的，也不太需要自已去造輪子刻，拿來用就好了。
這種會分二種情況:第一種是自已資料的展開，第二種是給二個資料組合展開。
Combination const choose = (n, xs) =&amp;gt; n &amp;lt; 1 || n &amp;gt; xs .length ? [] : n == 1 ? [...xs .map (x =&amp;gt; [x])] : [ ...choose (n - 1, xs .slice (1)) .map (ys =&amp;gt; [xs [0], ...ys]), ...choose (n , xs .slice (1)) ] const getCombs = (min, max, xs) =&amp;gt; xs .</description></item></channel></rss>