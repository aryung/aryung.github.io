<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>functional programming on AC分享小站</title><link>https://aryung.github.io/tags/functional-programming/</link><description>Recent content in functional programming on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Fri, 13 May 2022 09:30:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/functional-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>function mixins</title><link>https://aryung.github.io/posts/2022-05-13-function-mixins/</link><pubDate>Fri, 13 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-13-function-mixins/</guid><description>楔子 在公司的專案開發中，程式總會愈長愈大，會慢慢的到了一個程度難以理解，在開發的過程中也慢慢開始把程式做一些模組化的動作。
在程式的抽像化過程中，應該有二大派系很當使用，就是物件導向 &amp;amp; 函數式編程。通常會蠻常出現二個關鍵字
繼承(inheritance) 組合(composition) Mixins “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software”
有一種說法所謂的 mixins 就是像冰淇淋甜筒一樣，想吃什麼挖什麼口味，只要甜筒有那個味道功能，甜筒就只是一個載具而以。
Object composition 在 javascript 內，物件可以塞 function ，這時就要利用到 Object.assing 這個方法。
const chocolate = { hasChocolate: () =&amp;gt; true } const caramelSwirl = { hasCaramelSwirl: () =&amp;gt; true } const pecans = { hasPecans: () =&amp;gt; true } const iceCream = Object.</description></item><item><title>升級 javascript 到 typescript</title><link>https://aryung.github.io/posts/2022-05-12-upgrade-functional-programming-to-typescript/</link><pubDate>Thu, 12 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-12-upgrade-functional-programming-to-typescript/</guid><description>楔子 typescript 針對 javascript 有進行型別的補強，在 functional programming 的 lib 中，有 fp-ts 可以使用，不過個人覺的它有點複雜變的不太好用，它的型別有點太多了，先了解它的東西應該就飽了，那今天來試試改用小刀水平的 javascript 吧。
說明 先要熟悉一下 arrow function 的 typescript 有點不易閱讀(官網也這樣說)
這是一個取第一個值的簡單函數
let fst: (a: any, b: any) =&amp;gt; any = (a, b) =&amp;gt; a 如果套上括號(弄個特殊的括號 [ ] )，應該就可以比較好懂這個格式了。
let fst: [(a: any, b: any) =&amp;gt; any] = (a, b) =&amp;gt; a
比較容易理解的還是用純 function 來寫
function fst(a: any, b: any): any { return a } 如果再套上 Generic types 的表達格式</description></item></channel></rss>