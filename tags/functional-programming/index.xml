<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>functional programming on AC分享小站</title><link>https://aryung.github.io/tags/functional-programming/</link><description>Recent content in functional programming on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Tue, 17 May 2022 09:30:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/tags/functional-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Monad vs Promise</title><link>https://aryung.github.io/posts/2022-05-17-monad-meet-promise/</link><pubDate>Tue, 17 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-17-monad-meet-promise/</guid><description>楔子 來試著說明何謂 monad 這其實是數學的一個名稱，但撇開那些艱深的道理，試試來用 Promise 的例子來說明看看。
Function Compose 最原始的 compose 的觀念就是把多個 function 做組合
const x = 20 const f = n =&amp;gt; n * 2 const arr = Array.of(x) const result = arr.map(f) 例如 echo 就是吃二個參數回傳一個 function
const echo = n =&amp;gt; x =&amp;gt; Array.from({length: n}).fill(x) console.log( [1,2,3].map( echo(3) ) ) 例如 flatMap 就是吃二個參數回傳一個 function
const flatMap = (f, arr) =&amp;gt; [].concat(...arr.map(f)) const echo = n =&amp;gt; x =&amp;gt; Array.</description></item><item><title>lens laws</title><link>https://aryung.github.io/posts/2022-05-15-lens-laws/</link><pubDate>Sun, 15 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-15-lens-laws/</guid><description>楔子 在 functional programming 中要進行對 store 的設定時，可以用 lens 的方式來進行設定，如果就像一個吸管直接定位來改變值，進行值也可以用函數來取代。
lens laws laws
view(lens, set(lens, store, a)) = a 如果你改變了 store 某個值之後再立刻利用 lens 來取 store 的值，二個會相等(白話的意思就是你改變了 store 的值再拿出來看就是那個值) set(lens, b, set(lens, store, a)) = set(lens, b, store) 如果你改變了 store 的值為 a 又立馬改變值為 b，等同於直接改變值為 b(白話的意思就是你把一個值設了二次，最後的結果是第二次的值) set(lens, view(lens, store), store) = store 如果你用 lens 拿了某個值出來再同時 set 在 store 的 lens 位置的值，store 和原來的一致(白話文就是你取個 lens 的值拿出來的值再設到同一個 lens，該 store 維持不變) const view = (lens, store) =&amp;gt; lens.</description></item><item><title>function mixins</title><link>https://aryung.github.io/posts/2022-05-13-function-mixins/</link><pubDate>Fri, 13 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-13-function-mixins/</guid><description>楔子 在公司的專案開發中，程式總會愈長愈大，會慢慢的到了一個程度難以理解，在開發的過程中也慢慢開始把程式做一些模組化的動作。
在程式的抽像化過程中，應該有二大派系很當使用，就是物件導向 &amp;amp; 函數式編程。通常會蠻常出現二個關鍵字
繼承(inheritance) 組合(composition) Mixins “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software”
有一種說法所謂的 mixins 就是像冰淇淋甜筒一樣，想吃什麼挖什麼口味，只要甜筒有那個味道功能，甜筒就只是一個載具而以。
Object composition 在 javascript 內，物件可以塞 function ，這時就要利用到 Object.assign 這個方法。
const chocolate = { hasChocolate: () =&amp;gt; true } const caramelSwirl = { hasCaramelSwirl: () =&amp;gt; true } const pecans = { hasPecans: () =&amp;gt; true } const iceCream = Object.</description></item><item><title>升級 javascript 到 typescript</title><link>https://aryung.github.io/posts/2022-05-12-upgrade-functional-programming-to-typescript/</link><pubDate>Thu, 12 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-12-upgrade-functional-programming-to-typescript/</guid><description>楔子 typescript 針對 javascript 有進行型別的補強，在 functional programming 的 lib 中，有 fp-ts 可以使用，不過個人覺的它有點複雜變的不太好用，它的型別有點太多了，先了解它的東西應該就飽了，那今天來試試改用小刀水平的 javascript 吧。
說明 先要熟悉一下 arrow function 的 typescript 有點不易閱讀(官網也這樣說)
這是一個取第一個值的簡單函數
let fst: (a: any, b: any) =&amp;gt; any = (a, b) =&amp;gt; a 如果套上括號(弄個特殊的括號 [ ] )，應該就可以比較好懂這個格式了。
let fst: [(a: any, b: any) =&amp;gt; any] = (a, b) =&amp;gt; a
比較容易理解的還是用純 function 來寫
function fst(a: any, b: any): any { return a } 如果再套上 Generic types 的表達格式</description></item></channel></rss>