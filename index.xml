<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>AC 分享小站</title><link>https://aryung.github.io/</link><description>Recent content on AC 分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Thu, 26 May 2022 18:29:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>what is monad by Haskell</title><link>https://aryung.github.io/posts/what-is-monad-by-haskell/</link><pubDate>Thu, 26 May 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/what-is-monad-by-haskell/</guid><description>楔子 Monad 是一個數學特性，來看看純的 Haskell 語言怎看待，使用「除法」來做一個簡單的示範說明。
Monads 這是一個 Haskell 基本的語法，宣告一個 Expre 的格式，他有可能是 Int (Val type) ，也有可能是 Div
data Expr = Val Int | Div Expr Expr eval :: Expr -&amp;gt; Int eval (Val n) = n eval (Div x y) = eval x `div` eval y eval (Div (Val 1) (Val 0)) safediv :: Int -&amp;gt; Int -&amp;gt; Maybe Int safediv _ 0 = Nothing safediv n m = Just (n ‘div‘ m) eval :: Expr -&amp;gt; Maybe Int eval (Val n) = Just n eval (Div x y) = case eval x of Nothing -&amp;gt; Nothing Just n -&amp;gt; case eval y of Nothing -&amp;gt; Nothing Just m -&amp;gt; safediv n m eval :: Expr -&amp;gt; Maybe Int eval (Val n) = pure n eval (Div x y) = pure safediv &amp;lt;*&amp;gt; eval x &amp;lt;*&amp;gt; eval y (&amp;gt;&amp;gt;=) :: Maybe a -&amp;gt; (a -&amp;gt; Maybe b) -&amp;gt; Maybe b mx &amp;gt;&amp;gt;= f = case mx of Nothing -&amp;gt; Nothing Just x -&amp;gt; f x eval :: Expr -&amp;gt; Maybe Int eval (Val n) = Just n eval (Div x y) = eval x &amp;gt;&amp;gt;= \n -&amp;gt; eval y &amp;gt;&amp;gt;= \m -&amp;gt; safediv n m m1 &amp;gt;&amp;gt;= \x1 -&amp;gt; m2 &amp;gt;&amp;gt;= \x2 -&amp;gt; .</description></item><item><title>useContext Provider Consumer</title><link>https://aryung.github.io/posts/2022-05-23-usecontext-provider-consumer/</link><pubDate>Mon, 23 May 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-23-usecontext-provider-consumer/</guid><description>楔子 context 就語意上指的就是一個「環境」的概念，就如果轉成電腦來說就是「State」的意思。
而在 react component 有幾種情況可以夾帶這些「環境變數」
props state React 提供了另一個手法「context」來簡化語法
The Context API const LocaleContext = React.createContext(); LocaleContext 有二個屬性: Provider &amp;amp; Consumer
Provider allows us to &amp;ldquo;declare the data that we want available throughout our component tree&amp;rdquo;.
Consumer allows &amp;ldquo;any component in the component tree that needs that data to be able to subscribe to it&amp;rdquo;.
Provider 提供一個 value 的 props
&amp;lt;MyContext.Provider value={data}&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/MyContext.Provider&amp;gt; 比較完整的 code
// LocaleContext.</description></item><item><title>Arrow function generic types</title><link>https://aryung.github.io/posts/2022-05-22-arrow-function-generic-types/</link><pubDate>Sun, 22 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-22-arrow-function-generic-types/</guid><description>楔子 Arrow Function 很常使用，但它的 Generic Type 有點不太好記，列舉一下幾種
Generic Arrow Functions 正常的函數 Generice Type 的格式
function firstOrNull&amp;lt;T&amp;gt;(arr: T[]): T | null { return arr.length === 0 ? null : arr[0]; } General const firstOrNull = &amp;lt;T&amp;gt;( arr: T[] ): T | null =&amp;gt; arr.length === 0 ? null : arr[0]; Extends trick const firstOrNull = &amp;lt;T extends unknown&amp;gt;( arr: T[] ): T | null =&amp;gt; arr.length === 0 ? null : arr[0]; Comma trick const firstOrNull = &amp;lt;T,&amp;gt;( arr: T[] ): T | null =&amp;gt; arr.</description></item><item><title>Lambda Calculus</title><link>https://aryung.github.io/posts/2022-05-21-lambda-calculus/</link><pubDate>Sat, 21 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-21-lambda-calculus/</guid><description>楔子 這是一個在計算機歷史用數學演化的方式，具有代表性的規律。
Lambda (λ) Calculus Function Abstraction 能夠用簡單的方式來呈現函數
λx.x^2 + 1
用 js 來表示
let res = x =&amp;gt; x * x + 1 Function Application 何謂 β-reduction(beta reduction) ? 就是把「值」代入取得最後的計算結果
let res = (x =&amp;gt; x * x + 1)(3) 但有些情況不符合 curry 的表示法
λxy.x*y
就應該轉換成
(λx.(λy.x*y))
但其實 ( ) 是可以被簡化的
λx.λy.x*y
如果先代入一個數值 5
(λx.(λy.x*y)) (5) = (λy.5*y)
再代入 7
(λy.5*y)(7) = 35
用 javascript 來表示
function product(x, y) { return x * y; } product(5, 7) //retuns 35 // curry function product (x) { return function (y) { return x * y; } } 參考資料</description></item><item><title>寫給想跳坑的 JS 新手(Part II): coding style</title><link>https://aryung.github.io/posts/2022-05-20-javascript-newbie-part-ii/</link><pubDate>Fri, 20 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-20-javascript-newbie-part-ii/</guid><description>楔子 上一篇提到了 map filter reduce，這三個是最常見的也是最常用的使用方法，為了讓「程式碼」易讀，可以改造一下長相方便讓人看的懂在做什麼，至於怎做的就交給專業的人去優化改善就好。
所以先至少讓別人看的懂自已在寫的東西優先，試想看看，如果你是看 code 的人，「看的懂」vs 「要花一點點時間去細看」這二種，哪一種比較好讀? 先做到至少菜端出來看起來想吃，至於好不好吃就再說囉。嘿嘿嘿
程式碼的味道 用個最簡單的例子，把一個數字 x3 之後再 +1，但當數字是 5時就返回原值
f(1) = 1 * 3 + 1
f(5) = 5 來寫出這個 f 但我們用不同的長相來看看
撒尿牛丸全部攪在一起 這個應該是大部份的程式羅輯，就是把資料拆開來一個一個處理。
function f(x) { if(x !== 5) { return 3 * x + 1 } else { return x } } 點點點到天邊 這個 coding-style 就像你打開一個箱子把東西拿出來，「動作」後再放回去，依序處理。
let box = x =&amp;gt; ({f: f =&amp;gt; box(f(x)), x}) box(1) .f(multi3) .f(add1) // {f: ƒ f(), x: 4} box(5) .</description></item><item><title>寫給想跳坑的 JS 新手(Part I): map filter reduce</title><link>https://aryung.github.io/posts/2022-05-19-javascript-functional-programming-newbie-i/</link><pubDate>Thu, 19 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-19-javascript-functional-programming-newbie-i/</guid><description>楔子 身邊有些朋友有不少會想試著寫寫程式，常常坊間書翻一翻看到物件的東西，很快的就把書放下了，慢慢的也就失去興趣了。
但其實怎讓這些朋友開始可以有些動手做也能跑出一些結果，那種成就感會讓人慢慢的親近寫程式(coding)，不可否認物件導向語言統治了軟體界，但光要先學會這個觀念可能就讓人却步了。
以前有部電影「張三峰」有句台詞，怎「張無忌」問，怎學會這部武功?「張三峰」說:「忘掉就好了」。
其實函數式語言的「入門」蠻簡單的，就像小時候的數學，函數吃一些變數，跑出來一個結果，用這個方式寫寫東西就可以做一些小實務的作品，也很有成就感。
就讓我們試試吧..
Declarative 宣告式 vs. Imperative 命令式 命令式(Imperative)白話文就是要用電腦的角度去思考，怎把答案做出來。
如果相要把一連串的資料去掉一些特定值(前提條件就要知道何謂 for-loop)，示範的程式碼大概會長成下面的樣子
function filter(array) { let newArray = [] for (let index = 0; index &amp;lt; array.length; index++) { const element = array[index] if (element !== null &amp;amp;&amp;amp; element !== undefined) { newArray[newArray.length] = element } } return newArray } // use case: filter([0, 1, undefined, 2, null, 3, &amp;#39;four&amp;#39;, &amp;#39;&amp;#39;]) // [0, 1, 2, 3, &amp;#39;four&amp;#39;, &amp;#39;&amp;#39;] 但如果是所謂的宣告(Declarative)式，就是使用 filter 函數(知道 map/filter/reduce.</description></item><item><title>Monad Compose</title><link>https://aryung.github.io/posts/2022-05-18-monad-compose/</link><pubDate>Wed, 18 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-18-monad-compose/</guid><description>楔子 今天再來進階一下改寫 Monad compose
Monad 特徵 of: a =&amp;gt; M(a) 也有人叫 lift 或 type lift map: map 的 f :: a =&amp;gt; M(b) 會變成 M(M(b)) flatten: M(M(b)) =&amp;gt; M(b) Monad 有 flapMap 的概念
flatMap = Map + flatten : f(a).flatMap(g) =&amp;gt; M(b) const MyMonad = value =&amp;gt; ({ flatMap: f =&amp;gt; f(value), map (f) { return this.flatMap(a =&amp;gt; Monad.of(f(a))), }, }) Monad.of = x =&amp;gt; Monad(x) Monad(21).map( x =&amp;gt; x * 2).</description></item><item><title>Monad vs Promise</title><link>https://aryung.github.io/posts/2022-05-17-monad-meet-promise/</link><pubDate>Tue, 17 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-17-monad-meet-promise/</guid><description>楔子 來試著說明何謂 monad 這其實是數學的一個名稱，但撇開那些艱深的道理，試試來用 Promise 的例子來說明看看。
Function Compose 最原始的 compose 的觀念就是把多個 function 做組合
const x = 20 const f = n =&amp;gt; n * 2 const arr = Array.of(x) const result = arr.map(f) 例如 echo 就是吃二個參數回傳一個 function
const echo = n =&amp;gt; x =&amp;gt; Array.from({length: n}).fill(x) console.log( [1,2,3].map( echo(3) ) ) 例如 flatMap 就是吃二個參數回傳一個 function
const flatMap = (f, arr) =&amp;gt; [].concat(...arr.map(f)) const echo = n =&amp;gt; x =&amp;gt; Array.from({length: n}).</description></item><item><title>lens laws</title><link>https://aryung.github.io/posts/2022-05-15-lens-laws/</link><pubDate>Sun, 15 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-15-lens-laws/</guid><description>楔子 在 functional programming 中要進行對 store 的設定時，可以用 lens 的方式來進行設定，如果就像一個吸管直接定位來改變值，進行值也可以用函數來取代。
lens laws laws
view(lens, set(lens, store, a)) = a 如果你改變了 store 某個值之後再立刻利用 lens 來取 store 的值，二個會相等(白話的意思就是你改變了 store 的值再拿出來看就是那個值) set(lens, b, set(lens, store, a)) = set(lens, b, store) 如果你改變了 store 的值為 a 又立馬改變值為 b，等同於直接改變值為 b(白話的意思就是你把一個值設了二次，最後的結果是第二次的值) set(lens, view(lens, store), store) = store 如果你用 lens 拿了某個值出來再同時 set 在 store 的 lens 位置的值，store 和原來的一致(白話文就是你取個 lens 的值拿出來的值再設到同一個 lens，該 store 維持不變) const view = (lens, store) =&amp;gt; lens.</description></item><item><title>function mixins</title><link>https://aryung.github.io/posts/2022-05-13-function-mixins/</link><pubDate>Fri, 13 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-13-function-mixins/</guid><description>楔子 在公司的專案開發中，程式總會愈長愈大，會慢慢的到了一個程度難以理解，在開發的過程中也慢慢開始把程式做一些模組化的動作。
在程式的抽像化過程中，應該有二大派系很當使用，就是物件導向 &amp;amp; 函數式編程。通常會蠻常出現二個關鍵字
繼承(inheritance) 組合(composition) Mixins “Favor object composition over class inheritance” the Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software”
有一種說法所謂的 mixins 就是像冰淇淋甜筒一樣，想吃什麼挖什麼口味，只要甜筒有那個味道功能，甜筒就只是一個載具而以。
Object composition 在 javascript 內，物件可以塞 function ，這時就要利用到 Object.assign 這個方法。
const chocolate = { hasChocolate: () =&amp;gt; true } const caramelSwirl = { hasCaramelSwirl: () =&amp;gt; true } const pecans = { hasPecans: () =&amp;gt; true } const iceCream = Object.assign( {}, chocolate, caramelSwirl, pecans ) console.</description></item><item><title>升級 javascript 到 typescript</title><link>https://aryung.github.io/posts/2022-05-12-upgrade-functional-programming-to-typescript/</link><pubDate>Thu, 12 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-12-upgrade-functional-programming-to-typescript/</guid><description>楔子 typescript 針對 javascript 有進行型別的補強，在 functional programming 的 lib 中，有 fp-ts 可以使用，不過個人覺的它有點複雜變的不太好用，它的型別有點太多了，先了解它的東西應該就飽了，那今天來試試改用小刀水平的 javascript 吧。
說明 先要熟悉一下 arrow function 的 typescript 有點不易閱讀(官網也這樣說)
這是一個取第一個值的簡單函數
let fst: (a: any, b: any) =&amp;gt; any = (a, b) =&amp;gt; a 如果套上括號(弄個特殊的括號 [ ] )，應該就可以比較好懂這個格式了。
let fst: [(a: any, b: any) =&amp;gt; any] = (a, b) =&amp;gt; a
比較容易理解的還是用純 function 來寫
function fst(a: any, b: any): any { return a } 如果再套上 Generic types 的表達格式
function fst&amp;lt;T,U&amp;gt;(a: T, b: U): T { return a } 接下來開始改造 lib 升級到 typescript 先從小的東西開始，如果原來的 javascript</description></item><item><title>react rule of hook</title><link>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</link><pubDate>Tue, 10 May 2022 09:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-10-react-rule-of-hook/</guid><description>楔子 React 改成 functional component 最方便用的方式，在整個 code syntax 也是簡潔，不過當新舊交換時，常常難免會有一些使用上的規範。
rule of hook 直接用 Tyler 的範例來標示 rule
function Counter () { // 👍 from the top level function component const [count, setCount] = React.useState(0) if (count % 2 === 0) { // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } const handleIncrement = () =&amp;gt; { setCount((c) =&amp;gt; c + 1) // 👎 not from the top level React.useEffect(() =&amp;gt; {}) } } function useAuthed() { // 👍 from the top level of a custom Hook const [authed, setAuthed] = React.</description></item><item><title>React.createElement vs ReactDOM.render</title><link>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</link><pubDate>Mon, 09 May 2022 09:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</guid><description>楔子 最近小夥伴問了，React 的 jsx 基本的結構長如何，是如何轉換的之類的，順便記錄一下網路大神的資料摘錄。
React 有一個 createElement 的方法可以把資料轉成 react 特殊的結構 React.createElement('div', props={}) 收到特殊的結構之後再由 ReactDOM.render 來進行放在 html 上的位置 ReactDOM.render(jsDOM, document.getElementById('root')) React Basic React vs ReactDOM 摘錄一些 Kent 的示範 code 來演示一下，element 1 ~ 3 就是各種 jsDOM 的寫法，比較特別的是 React.createElement 可以有 2 ~3 個輸入參數
第一個參數指的是 HTML 的 DOM 種類(eg. div span &amp;hellip;) 第二個參數輸入的是該 DOM 的 props 第三個參數輸入的是 children const element1 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}) const element2 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}, &amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;World&amp;#39;) const element3 = React.</description></item><item><title>callback promise async/await</title><link>https://aryung.github.io/posts/2022-05-04-callback-promise-async-await/</link><pubDate>Wed, 04 May 2022 09:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-04-callback-promise-async-await/</guid><description>楔子 同樣的 javascript 針對所謂的 async 有其發生的歷史變革，有興趣的可以去找找影片了解一下。
callback 一開始採用的方式就是使用一個 callback function，因為 javascript 可以把 function 當參數丟入另一個 function，就有了最原始的模式，基本的概念就是
function executeFunc(callbackFun) { // some async function call callbackFun() } 題型: 請使用 setTimeout 來寫一個 1秒後 console.log(100) 的 callback function case // step 1. define function to run function go(){ // step 2. use setTimeout callback function to run after 1 sec setTimeout(()=&amp;gt; { // step 3. write console 100 }, sec) } // step 4. run the function go() 比對一下結果&amp;hellip;</description></item><item><title>Dockerfile 小練習</title><link>https://aryung.github.io/posts/2022-05-02-dockerfile-write/</link><pubDate>Mon, 02 May 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-02-dockerfile-write/</guid><description>楔子 Docker 是現在開發的基本工，除了不想污染本地的環境以外，更重要的是可以把執行環境標準化，不會因為不同的環境就有無法執行的狀況，來試著了解一下吧。
網路的 docker 說明介紹蠻多的，就不多做說明了，就比較用講解的方式來自已可以寫一個所屬的 dockerfile 的實做羅輯。
環境架構 自行參考相關安裝
MacOS linux windows 認識 images 與 tag 來試看看 ubuntu 的 base image 來看， (image name):(tag) 這是基本的格式，這個格式可以使用在 dockerfile 內。 ubuntu example
試題來試試 case I Hint: (為 dockerfile 指令)
基礎的影像 base image (FROM)
每個程式都會歷經 build test(optional) runtime 的過程 (RUN CMD)
把原來的程式碼 copy 到 docker 內的 workdir (COPY WORKDIR)
安裝相關程式(dependency) (RUN)
試著寫出一個 NodeApp Dockerfile 提示: 下方為 build &amp;amp; runtime 的 bash 指令
npm run build npm run start dockerfile 步驟</description></item><item><title>more about prototypes</title><link>https://aryung.github.io/posts/2022-05-01-more-about-prototype-chain/</link><pubDate>Sun, 01 May 2022 18:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-01-more-about-prototype-chain/</guid><description>楔子 原型鏈 (prototype chain) 應該是 javascript 新人入門最討厭的東西了。
在這個語言中其實只有幾大類別(number string boolean)
Undefined (undefined), used for unintentionally missing values. Null (null), used for intentionally missing values. Booleans (true and false), used for logical operations. Numbers (-100, 3.14, and others), used for math calculations. BigInts (uncommon and new), used for math on big numbers. Strings (&amp;ldquo;hello&amp;rdquo;, &amp;ldquo;abracadabra&amp;rdquo;, and others), used for text. Symbols (uncommon), used to perform rituals and hide secrets. 比較特別的就是 Object 和 Function 了，先摘錄一些網路大神的圖解。</description></item><item><title>composition over inheritance</title><link>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</link><pubDate>Fri, 29 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</guid><description>楔子 如果平常在寫 OOP(物件導向)語言的人，應該就會很熟悉繼承(inheritance);如果有寫 ruby 的人，應該更熟悉鴨子型別(duck typing);如果在寫 FP(functional programming)的，就更熟悉組合(composition)。每個語言都有他的特性，端看怎使用而以，語言的熟悉度就在於這些手法的習性而以。
但在 javascript 中其實都可以實踐這些特性來讓不同的技術人來使用，今天就拿一些網站的 demo code 來分享。
code 先來看看標準的 es2015 的 classes &amp;amp; prototype
Inheritance with Classes
// case I prototype var Animal = function(name) { this.name = name } var Alligator = function(name) { Animal.apply(this, arguments); // Call parent constructor } Alligator.prototype = Object.create(Animal.prototype) Alligator.prototype.constructor = Alligator var jack = new Alligator(&amp;#34;jack&amp;#34;) // case II classes class Animal { constructor(name) { this.name = name } } class Alligator extends Animal {} const jack = new Alligator(&amp;#34;jack&amp;#34;) // extends class Alligator extends Animal { constructor(.</description></item><item><title>kubernetes terraform helm 起手式</title><link>https://aryung.github.io/posts/2022-04-28-kubernetes-terraform-helm/</link><pubDate>Thu, 28 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-28-kubernetes-terraform-helm/</guid><description>楔子 現在雲端化的產品服務這麼多，怎一開始入門來使用這些服務，這次來聊聊這個話題吧。
觀念 主要有幾個東西:
kubernetes:負責 app 的擴展，穩定服務等等 helm:負責產生 kubernetes 的設定參數樣版文件 terraform:負責來設定雲端的資源環境 為了不讓東西討論到細節，就先簡單把 kubernetes 想像成可以使用的程式，而 helm 就想像成去設定程式的一些參數，而 terraform 想像成要用哪些資源。 當然可以去花點時間去官網看看詳細的介紹。
環境 為了在本地端使用開發測試，就本地安裝 minikube 來替代 kubernetes ，再簡化說明， helm 就是這些設定 kubernetes 的相關設定，至於 terraform 就當做設定這些程式所需要的相關資源(eg.多大的 cpu 和 ram)
示範 code 使用 terraform + kubernetes config terraform 要設定幾個東西
kubernetes mysql deployment &amp;amp; mysql service wordpress deployment &amp;amp; wordpress service provider &amp;#34;kubernetes&amp;#34; { config_context = &amp;#34;minikube&amp;#34; } locals { wordpress_labels = { App = &amp;#34;wordpress&amp;#34; Tier = &amp;#34;frontend&amp;#34; } mysql_labels = { App = &amp;#34;wordpress&amp;#34; Tier = &amp;#34;mysql&amp;#34; } } resource &amp;#34;kubernetes_secret&amp;#34; &amp;#34;mysql-pass&amp;#34; { metadata { name = &amp;#34;mysql-pass&amp;#34; } data = { password = &amp;#34;root&amp;#34; } } resource &amp;#34;kubernetes_deployment&amp;#34; &amp;#34;wordpress&amp;#34; { metadata { name = &amp;#34;wordpress&amp;#34; labels = local.</description></item><item><title>useContext Provider 起手式</title><link>https://aryung.github.io/posts/2022-04-08-hook-context-provider/</link><pubDate>Fri, 08 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-08-hook-context-provider/</guid><description>楔子 useContext 是 hook 系列很常使用的東西，通常就在「跨」 components 之間使用，有時加減也好用也有點濫用，說說比較常使用的情境吧..
例如像 Global Theme 在所有的 component 都包上一層，像 Material UI 就採用這種模式..
那像假設 firebase Oauth 的情況時，要用嗎?還是可以用 custom hook?其實這二種方式都有人用，看自已的習慣而以..
一般式 這是比較正常的方式，最外層包一個 Provider 再利用 render prop 來操作
import React from &amp;#39;react&amp;#39;; export const UserContext = React.createContext(); export default function App() { return ( &amp;lt;UserContext.Provider value=&amp;#34;user&amp;#34;&amp;gt; &amp;lt;User /&amp;gt; &amp;lt;/UserContext.Provider&amp;gt; ) } function User() { return ( &amp;lt;UserContext.Consumer&amp;gt; {value =&amp;gt; &amp;lt;h1&amp;gt;{value}&amp;lt;/h1&amp;gt;} &amp;lt;/UserContext.Consumer&amp;gt; ) } Kent c dodds 但其實如果使用 Kent 的起手式，其實蠻優美的.. Kent useContext code</description></item><item><title>JS 大魔王 this</title><link>https://aryung.github.io/posts/2022-03-30-this/</link><pubDate>Wed, 30 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-30-this/</guid><description>楔子 JS 的 this 通常有所謂的 scope 問題，最近蠻常遇到小夥伴在問，就順便做一下整理，而且通常this會和class一起出現使用。
this 單獨使用 大概有幾種情況
默認綁定(default binding) 在 function 內的 this 為 function 上一層，strict模式為 undefined function main(){ console.log(this) // this = global } main() 隱式綁定(implicit binding) var person = { name: &amp;#39;ac&amp;#39;, getName: function() { console.log(this) // this = person } } person.getName() // &amp;#39;ac&amp;#39; function click(cb){ cb() } var name = &amp;#39;aac&amp;#39; click(person.getName) // 把 person.getName 丟到 click 的參數時 // 這時的 this = global，這時 global.</description></item><item><title>JS 其實不是 class 的好朋友</title><link>https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/</link><pubDate>Sun, 27 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/</guid><description>楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應，有趣的現象是在 js 環境下，後端很常用 OOP: class style.
但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下， 就可能要去準備一下 class style 的 JS/Node。
而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。
tl;dr
一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。
不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，反而會比較有感就感。當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..實務上的差異並不太大，踩到坑再去記住會身體更有感覺。
通常 this 會和 class 一起使用，而其實this就把它當成context(環境參數)來看待就可以了。
Object.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method
var objTemplate = {name: &amp;#39;yo&amp;#39;} var childObj = Object.</description></item><item><title>GraphQL Server 方案</title><link>https://aryung.github.io/posts/2022-03-23-graphql-server/</link><pubDate>Wed, 23 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-23-graphql-server/</guid><description>楔子 GraphQL Server 的基本架構大概就幾個主要的元件:
types 資料結構定義 Server 伺服服務 resolver 資料整理用 模版的東西就拿來改比較快，畢竟自已搞定也要很有愛。
codesandbox
市面上常用的大概就 apollor server，要自已寫 types 和 resolvers。
另一個比較好用的有 prisma ，它本身有包含 database ORM 的功用，
也有自動產出 client 段方便套在自已的前端 web。
雜談 其實在 GraphQL 中，最重要的就是 types &amp;amp; resolvers，
這二個的意函在哪裡? types 其實就想像成資料的欄位設定，
resolvers 就想像成取得資料要進行「加減乘除」等等處理的方法。
如果從架構的角度來看
client(Framework) &amp;lt;-&amp;gt; (server &amp;lt;-&amp;gt; database)
在 client 和 server 端為了要彼此能溝通，勢必就要有一個標準的 types 來做依據。
就指的是 client 和 server 端其實都各自要能吃同樣的 types &amp;amp; 解析 query-languages
在 server 端，就因為常常有舊的資料庫問題，那是不是這個 type 同時也能滿足 ORM 的功能?
所以像 prisma 的服務就同時幫你產出 client.</description></item><item><title>graphql use case</title><link>https://aryung.github.io/posts/2022-03-21-graphql-intro/</link><pubDate>Mon, 21 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-21-graphql-intro/</guid><description>楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點， 久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯， 慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件， 但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。
GraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema &amp;amp; 路由 routes)，
這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。
Server 元件 要架一個 GraphQL Server，思考一下要什麼東西??
就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理
Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type &amp;amp; schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等) server var express = require(&amp;#39;express&amp;#39;) var { graphqlHTTP } = require(&amp;#39;express-graphql&amp;#39;) var { buildSchema } = require(&amp;#39;graphql&amp;#39;) var schema = buildSchema(` type Query { hello: String } `) var root = { hello: () =&amp;gt; &amp;#39;Hello world!</description></item><item><title>如何使用 try catch</title><link>https://aryung.github.io/posts/2022-03-18-fp-trycatch/</link><pubDate>Fri, 18 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-18-fp-trycatch/</guid><description>楔子 寫程式時噴錯誤是蠻常見的，就每發生一個錯誤，再加一個條件去排除錯誤的問題
往往如此， code 就會開始蠻的有點「巢狀」的感覺
if(check) { // 1-level if(check) { // 2-level if(check) { // 3-level } else { // 3-level } } else { // 2-level } } else { // 1-level } 原來的 try-catch 標準的 try-catch 程式長相大概如下， try-catch 主要的功用就是避免程式噴錯跳離
try { // do something } catch (e) { console.log(e.message) } 但也常常有個問題就是錯誤的類型如果不確定，就常常一直補 code 除錯。
所以常常的流程大概就是
包一個 try-catch ，噴錯看 log ，補 if-else 的 bug handling，再重覆 try-catch 的 log..
// version 1 function go(x) { try { let len = x.</description></item><item><title>Box 的好用之處</title><link>https://aryung.github.io/posts/2022-03-15-fp-box/</link><pubDate>Tue, 15 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-15-fp-box/</guid><description>楔子 程式碼是拿來使用的，今天就來分享一些小工具來幫助寫 code ，這些東西算是函數式編程的入門吧，用久了才會比較有感，今天就當來練練手。
先上個常用的 tool box
const pipe = (...fns) =&amp;gt; x =&amp;gt; fns.reduce((y, f) =&amp;gt; f(y), x) const I = x =&amp;gt; x const Box = x =&amp;gt; ({ chain: f =&amp;gt; f(x), map: f =&amp;gt; Box(f(x)), fold: f =&amp;gt; f(x), inspect: () =&amp;gt; `Box(${x})` }) const Right = x =&amp;gt; ({ chain : f =&amp;gt; f(x), map : f =&amp;gt; Right(f(x)), fold : (f, g) =&amp;gt; g(x), inspect : () =&amp;gt; `Right(${x})` }) const Left = x =&amp;gt; ({ chain : f =&amp;gt; Left(x), map : f =&amp;gt; Left(x), fold : (f, g) =&amp;gt; f(x), inspect : () =&amp;gt; `Left(${x})` }) const fromNullable = x =&amp;gt; (x === null || x === undefined || x.</description></item><item><title>Promise 新手常花時間的坑</title><link>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</link><pubDate>Sun, 13 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</guid><description>楔子 最近有些小夥伴在彼此討論時，常常出現一些不太知道原因，但改一改就好了，就隨手做一下筆記也方便提醒自已。
狀況一: 分不清楚有沒有回傳值 functo go1 () { return 1 } // 有回傳值 functin go2 () { console.log(3) } // 無回傳值 const go3 = () =&amp;gt; 2 const go4 = () =&amp;gt; { console.log(4) } // 無回傳值 function addOne (x) { return x } const go5 = () =&amp;gt; addOne(3) const go6 = () =&amp;gt; { 7 } const go7 = (x) =&amp;gt; ({x}) 從上面的問題來看，最直覺的就是要有 return 字眼就是代表有回傳值，所以 go1 go2 很容易判斷。</description></item><item><title>Hight Order Function &amp; Callback Function</title><link>https://aryung.github.io/posts/2022-03-10-high-order-function/</link><pubDate>Thu, 10 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-10-high-order-function/</guid><description>楔子 最典型的使用案例是 jQuery 時代，標準的 jQuery 格式大概就長的像下面這樣的格式
// jQuery === $ var hiddenBox = $(&amp;#34;#banner-message&amp;#34;) jQuery(&amp;#34;#button-container button&amp;#34;).on(&amp;#34;click&amp;#34;, function(event) { hiddenBox.show() }) 通常簡化來看就是 $(DOMelement, clickFunction)，而 clickFunction 的長相像就也是像
function (event) { // event handling } 如果是把這種格式轉換一下，大概有幾個注意的要點:
參數可以是一個函數 函數以一個參數為佳 function add (x,y) { return x + y } function addFive (x, referenceCallback) { return referenceCallback(x) } addFive(10, add) // 標準化 function highOrderFunction (x, callback) { return callback(x) } 蠻多的 js 的函數也都採用這樣的 coding style。</description></item><item><title>React 設計模式: Compound Components</title><link>https://aryung.github.io/posts/2022-03-10-react-patten-compond-component/</link><pubDate>Thu, 10 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-10-react-patten-compond-component/</guid><description>楔子 摘錄 Kent 的 React Advance Pattern: Compond Components
這個設計模式有什特殊的點?
如果要做一個切換的鈕的元件，大概就會用一個變數來判斷要如何切換?
function App() { const [on, setOn] = React.useState(false) return ( &amp;lt;div&amp;gt; { on ? &amp;lt;div&amp;gt;The button is on&amp;lt;/div&amp;gt; : null } { on ? null : &amp;lt;div&amp;gt;The button is off&amp;lt;/div&amp;gt; } &amp;lt;/div&amp;gt; ) } 這樣的 code 就有點醜，那有沒有可能性把 code 長成這樣 ?
function App() { return ( &amp;lt;div&amp;gt; &amp;lt;Toggle&amp;gt; &amp;lt;ToggleOn&amp;gt;The button is on&amp;lt;/ToggleOn&amp;gt; &amp;lt;ToggleOff&amp;gt;The button is off&amp;lt;/ToggleOff&amp;gt; &amp;lt;ToggleButton /&amp;gt; &amp;lt;/Toggle&amp;gt; &amp;lt;/div&amp;gt; ) } 來完成 Toogle ToogleOn ToogleOff 這三個元件的寫法呢?</description></item><item><title>取得所有的組合再求結果</title><link>https://aryung.github.io/posts/2022-03-09-combination/</link><pubDate>Wed, 09 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-09-combination/</guid><description>使用情境 資料中任二組(或以上)符合某個條件
例如: 想找 [1,2,3,4,5] 任二個值「大於」3有哪些情況
二組資料的「所有組合」想找符合條件的結果
例如: [1,2,3,4] 和 [7,8.9] 的組合中那個「乘」大於 10
上面的情況在整理資料中蠻常發現的，所以手上有這個函數是蠻方便的，也不太需要自已去造輪子刻，拿來用就好了。
這種會分二種情況:第一種是自已資料的展開，第二種是給二個資料組合展開。
Combination const choose = (n, xs) =&amp;gt; n &amp;lt; 1 || n &amp;gt; xs .length ? [] : n == 1 ? [...xs .map (x =&amp;gt; [x])] : [ ...choose (n - 1, xs .slice (1)) .map (ys =&amp;gt; [xs [0], ...ys]), ...choose (n , xs .slice (1)) ] const getCombs = (min, max, xs) =&amp;gt; xs .</description></item><item><title>JS Prototype by Tyler McGinnis</title><link>https://aryung.github.io/posts/2022-03-08-uidot-prototype/</link><pubDate>Tue, 08 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-uidot-prototype/</guid><description>楔子 Tyler 講的 prototype 的觀念蠻清楚 &amp;amp; 簡單的，稍做一下記錄 Tyler McGinnis javascript
prototype Prototype is a property of a function that point to an object when function is created.
用下面的例子就可以來解釋上面的句子
function imAFunction () {} imAFunction.prototype // {constructor: f} 把共用的 Method 放在一起包裝在一個 Object 內
// 共用的 method const animalMethods() { eat () {}, sleep () {}, play () {} } function Animal (name, energy) { let animal = Object.crete(animalMethods) animal.name = name animal.energy = energy return animal } 關鍵字 new new 做的就只是把 Object.</description></item><item><title>如何在 useEffect 內使用 async function</title><link>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</link><pubDate>Tue, 08 Mar 2022 20:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</guid><description>使用情境 一開始的 API 呼叫把值塞進 React 搜尋 autocomplete 前端一開始開啟都會有呼叫 API 情境的狀況發生，比較基本的方式使用大概會長這樣子。
const Users = () =&amp;gt; { const [users, setUsers] = useState([]) useEffect(() =&amp;gt; { fetchUsers().then((users) =&amp;gt; setUsers(users)) }, []) if (!users) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt; return ( &amp;lt;ul&amp;gt; {users.map((user) =&amp;gt; ( &amp;lt;li&amp;gt;{user.name}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ) } 那如果要使用 async/await 呢?
很直覺的會這樣寫
// 直接在 useEffect 內使用 async useEffect(async () =&amp;gt; { const users = await fetchUsers() setUsers(users) }, []) 但會有一個情況發生，還記的 useEffect 有一個 cleanup function 嗎?</description></item><item><title>JS 原型說明 by Dan Abramov</title><link>https://aryung.github.io/posts/2022-03-08-justjavascript-prototype/</link><pubDate>Tue, 08 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-justjavascript-prototype/</guid><description>楔子 不同的大神針對 JS 有不同的說明講解，來看一下 Redux 作者的說明。
Dan Abramov 有一個 justjavascrpt prototype 其實把觀念寫的蠻好的。
這篇文章是其中一個 prototype 的內容摘錄如下:
先有一個觀念就是 a = '123' 中 a 是變數(variable)， 123 是值(value)
// teeth 是 variable // 32 是值 let human = { teeth: 32 } let gwen = { age: 19 } human 和 gwen 是一個 Object，他把屬性直接連到 值
// gwen 沒有 teeth 屬性 console.log(gwen.teeth) // undefined let human = { teeth: 32 } 如果當用 __proto__ 在 Object 裡面，=的右邊是一個變數，這是就是去找這個變數的 reference 在哪?</description></item><item><title>Neo4j: 圖資料庫</title><link>https://aryung.github.io/posts/2022-03-05-graph-database/</link><pubDate>Sat, 05 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-05-graph-database/</guid><description>楔子 平常使用的最多的應該是 MySQL 了，但通常不同的資料庫有它的使用情境。
簡單分就是有 SQL 和 NoSQL 系列，就二分法的方式處理。
各種資料庫都有它的好用的地方，像 NoSQL 比較有名的就 Redis (它有硬碟版 SSDB)
資料的結構常常會依據使用情境不同有所適合的資料庫。
今天來分享所謂的「圖型」資料庫，資料庫一開始比較需要掌握的就是「設計的理念」
最具代表性的就是 Neo4j
先來看一下它查詢的語法就比較容易理解他的概念。
MATCH (n {name: &amp;#39;John&amp;#39;})-[:FRIEND]-(friend) WITH n, count(friend) AS friendsCount WHERE friendsCount &amp;gt; 3 RETURN n, friendsCount 其實可以「感覺」的出來就是用「node」和「relationship」來做為查詢的方式，
在每個「node」的上面有屬性，而不同的屬性可以有「條件」來進行過濾。
node 用 () 來標記，關係用 [] 來表示
特徵 就自然有人問，那這個資料庫的好處在哪?
大家覺的「圖」這種的設計，比較常出現在哪? 答案就是 社群 ，它就是點和線的連結而以。
當有這個想法後，例如我好朋友的朋友有哪些?
MATCH (i {name: &amp;#39;me&amp;#39;})-[:FRIEND]-(f1:friend)-[:FRIEND]-(f2:friend) RETURN n, f1, f2 i = 我; f1 = 我朋友; f2 = 我朋友的朋友
如果想像用 RDBMS，就要用二層 select 來處理(或使用 sub-query)，</description></item><item><title>函數式編程 Functor 的運用</title><link>https://aryung.github.io/posts/2022-03-04-functional-programming-in-js-box/</link><pubDate>Fri, 04 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-04-functional-programming-in-js-box/</guid><description>特徵 可以把函數當參數使用 可以使用 compose(反向) 或 pipe(正向) 的串連方式 // 建立一個標準的函數 let func = f = x =&amp;gt; f(x) let addOne = x =&amp;gt; x + 1 let ff = func(addOne) // f = addOne ff(1) // 1+1 pipe 就像一個水管一樣串接不同的 function
const pipe = (...fns) =&amp;gt; x =&amp;gt; fns.reduce((y, f) =&amp;gt; f(y), x) pipe(x =&amp;gt; x + 1, x =&amp;gt; x + 2)(3) 練習看看 有了上面的東西，如何使用?
如果有興趣可以去看看 Dr.Boolean 的一些影片，擷取一些常用的工具來做使用。
const pipe = (...fns) =&amp;gt; x =&amp;gt; fns.</description></item></channel></rss>