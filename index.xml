<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>AC分享小站</title><link>https://aryung.github.io/</link><description>Recent content on AC分享小站</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Mon, 09 May 2022 09:29:06 +0800</lastBuildDate><atom:link href="https://aryung.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>callback promise async/await</title><link>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</link><pubDate>Mon, 09 May 2022 09:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-09-react-create-element-vs-reactdom-render/</guid><description>楔子 最近小夥伴問了，React 的 jsx 基本的結構長如何，是如何轉換的之類的，順便記錄一下網路大神的資料摘錄。
React 有一個 createElement 的方法可以把資料轉成 react 特殊的結構 React.createElement('div', props={}) 收到特殊的結構之後再由 ReactDOM.render 來進行放在 html 上的位置 ReactDOM.render(jsDOM, document.getElementById('root')) React Basic React vs ReactDOM 摘錄一些 Kent 的示範 code 來演示一下，element 1 ~ 3 就是各種 jsDOM 的寫法，比較特別的是 React.createElement 可以有 2 ~3 個輸入參數
第一個參數指的是 HTML 的 DOM 種類(eg. div span &amp;hellip;) 第二個參數輸入的是該 DOM 的 props 第三個參數輸入的是 children const element1 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}) const element2 = React.createElement(&amp;#39;div&amp;#39;, {className: &amp;#39;container&amp;#39;}, &amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;World&amp;#39;) const element3 = React.</description></item><item><title>callback promise async/await</title><link>https://aryung.github.io/posts/2022-05-04-callback-promise-async-await/</link><pubDate>Wed, 04 May 2022 09:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-04-callback-promise-async-await/</guid><description>楔子 同樣的 javascript 針對所謂的 async 有其發生的歷史變革，有興趣的可以去找找影片了解一下。
callback 一開始採用的方式就是使用一個 callback function，因為 javascript 可以把 function 當參數丟入另一個 function，就有了最原始的模式，基本的概念就是
function executeFunc(callbackFun) { // some async function call callbackFun() } 題型: 請使用 setTimeout 來寫一個 1秒後 console.log(100) 的 callback function case // step 1. define function to run function go(){ // step 2. use setTimeout callback function to run after 1 sec setTimeout(()=&amp;gt; { // step 3. write console 100 }, sec) } // step 4.</description></item><item><title>Dockerfile 小練習</title><link>https://aryung.github.io/posts/2022-05-02-dockerfile-write/</link><pubDate>Mon, 02 May 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-02-dockerfile-write/</guid><description>楔子 Docker 是現在開發的基本工，除了不想污染本地的環境以外，更重要的是可以把執行環境標準化，不會因為不同的環境就有無法執行的狀況，來試著了解一下吧。
網路的 docker 說明介紹蠻多的，就不多做說明了，就比較用講解的方式來自已可以寫一個所屬的 dockerfile 的實做羅輯。
環境架構 自行參考相關安裝
MacOS linux windows 認識 images 與 tag 來試看看 ubuntu 的 base image 來看， (image name):(tag) 這是基本的格式，這個格式可以使用在 dockerfile 內。 ubuntu example
試題來試試 case I Hint: (為 dockerfile 指令)
基礎的影像 base image (FROM)
每個程式都會歷經 build test(optional) runtime 的過程 (RUN CMD)
把原來的程式碼 copy 到 docker 內的 workdir (COPY WORKDIR)
安裝相關程式(dependency) (RUN)
試著寫出一個 NodeApp Dockerfile 提示: 下方為 build &amp;amp; runtime 的 bash 指令</description></item><item><title>more about prototypes</title><link>https://aryung.github.io/posts/2022-05-01-more-about-prototype-chain/</link><pubDate>Sun, 01 May 2022 18:30:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-05-01-more-about-prototype-chain/</guid><description>楔子 原型鏈 (prototype chain) 應該是 javascript 新人入門最討厭的東西了。
在這個語言中其實只有幾大類別(number string boolean)
Undefined (undefined), used for unintentionally missing values. Null (null), used for intentionally missing values. Booleans (true and false), used for logical operations. Numbers (-100, 3.14, and others), used for math calculations. BigInts (uncommon and new), used for math on big numbers. Strings (&amp;ldquo;hello&amp;rdquo;, &amp;ldquo;abracadabra&amp;rdquo;, and others), used for text. Symbols (uncommon), used to perform rituals and hide secrets. 比較特別的就是 Object 和 Function 了，先摘錄一些網路大神的圖解。</description></item><item><title>composition over inheritance</title><link>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</link><pubDate>Fri, 29 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-29-composition-over-inheritance/</guid><description>楔子 如果平常在寫 OOP(物件導向)語言的人，應該就會很熟悉繼承(inheritance);如果有寫 ruby 的人，應該更熟悉鴨子型別(duck typing);如果在寫 FP(functional programming)的，就更熟悉組合(composition)。每個語言都有他的特性，端看怎使用而以，語言的熟悉度就在於這些手法的習性而以。
但在 javascript 中其實都可以實踐這些特性來讓不同的技術人來使用，今天就拿一些網站的 demo code 來分享。
code 先來看看標準的 es2015 的 classes &amp;amp; prototype
Inheritance with Classes
// case I prototype var Animal = function(name) { this.name = name } var Alligator = function(name) { Animal.apply(this, arguments); // Call parent constructor } Alligator.prototype = Object.create(Animal.prototype) Alligator.prototype.constructor = Alligator var jack = new Alligator(&amp;#34;jack&amp;#34;) // case II classes class Animal { constructor(name) { this.</description></item><item><title>kubernetes terraform helm 起手式</title><link>https://aryung.github.io/posts/2022-04-28-kubernetes-terraform-helm/</link><pubDate>Thu, 28 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-28-kubernetes-terraform-helm/</guid><description>楔子 現在雲端化的產品服務這麼多，怎一開始入門來使用這些服務，這次來聊聊這個話題吧。
觀念 主要有幾個東西:
kubernetes:負責 app 的擴展，穩定服務等等 helm:負責產生 kubernetes 的設定參數樣版文件 terraform:負責來設定雲端的資源環境 為了不讓東西討論到細節，就先簡單把 kubernetes 想像成可以使用的程式，而 helm 就想像成去設定程式的一些參數，而 terraform 想像成要用哪些資源。 當然可以去花點時間去官網看看詳細的介紹。
環境 為了在本地端使用開發測試，就本地安裝 minikube 來替代 kubernetes ，再簡化說明， helm 就是這些設定 kubernetes 的相關設定，至於 terraform 就當做設定這些程式所需要的相關資源(eg.多大的 cpu 和 ram)
示範 code 使用 terraform + kubernetes config terraform 要設定幾個東西
kubernetes mysql deployment &amp;amp; mysql service wordpress deployment &amp;amp; wordpress service provider &amp;#34;kubernetes&amp;#34; { config_context = &amp;#34;minikube&amp;#34; } locals { wordpress_labels = { App = &amp;#34;wordpress&amp;#34; Tier = &amp;#34;frontend&amp;#34; } mysql_labels = { App = &amp;#34;wordpress&amp;#34; Tier = &amp;#34;mysql&amp;#34; } } resource &amp;#34;kubernetes_secret&amp;#34; &amp;#34;mysql-pass&amp;#34; { metadata { name = &amp;#34;mysql-pass&amp;#34; } data = { password = &amp;#34;root&amp;#34; } } resource &amp;#34;kubernetes_deployment&amp;#34; &amp;#34;wordpress&amp;#34; { metadata { name = &amp;#34;wordpress&amp;#34; labels = local.</description></item><item><title>useContext Provider 起手式</title><link>https://aryung.github.io/posts/2022-04-08-hook-context-provider/</link><pubDate>Fri, 08 Apr 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-04-08-hook-context-provider/</guid><description>楔子 useContext 是 hook 系列很常使用的東西，通常就在「跨」 components 之間使用，有時加減也好用也有點濫用，說說比較常使用的情境吧..
例如像 Global Theme 在所有的 component 都包上一層，像 Material UI 就採用這種模式..
那像假設 firebase Oauth 的情況時，要用嗎?還是可以用 custom hook?其實這二種方式都有人用，看自已的習慣而以..
一般式 這是比較正常的方式，最外層包一個 Provider 再利用 render prop 來操作
import React from &amp;#39;react&amp;#39;; export const UserContext = React.createContext(); export default function App() { return ( &amp;lt;UserContext.Provider value=&amp;#34;user&amp;#34;&amp;gt; &amp;lt;User /&amp;gt; &amp;lt;/UserContext.Provider&amp;gt; ) } function User() { return ( &amp;lt;UserContext.Consumer&amp;gt; {value =&amp;gt; &amp;lt;h1&amp;gt;{value}&amp;lt;/h1&amp;gt;} &amp;lt;/UserContext.Consumer&amp;gt; ) } Kent c dodds 但其實如果使用 Kent 的起手式，其實蠻優美的.. Kent useContext code</description></item><item><title>JS 大魔王 this</title><link>https://aryung.github.io/posts/2022-03-30-this/</link><pubDate>Wed, 30 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-30-this/</guid><description>楔子 JS 的 this 通常有所謂的 scope 問題，最近蠻常遇到小夥伴在問，就順便做一下整理，而且通常this會和class一起出現使用。
this 單獨使用 大概有幾種情況
默認綁定(default binding) 在 function 內的 this 為 function 上一層，strict模式為 undefined function main(){ console.log(this) // this = global } main() 隱式綁定(implicit binding) var person = { name: &amp;#39;ac&amp;#39;, getName: function() { console.log(this) // this = person } } person.getName() // &amp;#39;ac&amp;#39; function click(cb){ cb() } var name = &amp;#39;aac&amp;#39; click(person.getName) // 把 person.getName 丟到 click 的參數時 // 這時的 this = global，這時 global.</description></item><item><title>JS 其實不是 class 的好朋友</title><link>https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/</link><pubDate>Sun, 27 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-27-js-class-arrow-function/</guid><description>楔子 Coding Style 是一個很有意思的題目，往往不太一樣的 style 就會造成很不一樣的適應，有趣的現象是在 js 環境下，後端很常用 OOP: class style.
但在 React 的環境下就很 function style，但在 angular 的世界內就也是 oop。如果去面式 Node 的後端，如果是 full stack 前端比較熟悉 react 的情況下， 就可能要去準備一下 class style 的 JS/Node。
而在 backend 的夥伴要去應徵 React 的話，就也要熟悉 function style。
tl;dr
一開始入門 js 時，光搞懂這些 this class 的東西應該就飽了，而市面上的書藉也大多數都是先講完這些原理再來開始寫程式，感覺有點反過來了，寫程式總是先可以弄出東西再來慢慢理解為什麼，而一開始的架構沒很大時，光搞抽象弄懂這些額外的「知識」，就搞的暈頭轉向了。
不妨先試著用純 functional 的方式來寫一些東西，慢慢真的熟悉了，發現很多東西都開始好像 code 變的又臭又長時，再來解決這些抽象的東西，反而會比較有感就感。當看了下面一堆 js 的說明，光考就弄倒一堆人了，就自然討厭 js 了，但就算弄懂其實..實務上的差異並不太大，踩到坑再去記住會身體更有感覺。
通常 this 會和 class 一起使用，而其實this就把它當成context(環境參數)來看待就可以了。
Object.create Object.create 就是建立一個 Object 的模版資料，會依 prototype chian 去尋找相關的 method
var objTemplate = {name: &amp;#39;yo&amp;#39;} var childObj = Object.</description></item><item><title>GraphQL Server 方案</title><link>https://aryung.github.io/posts/2022-03-23-graphql-server/</link><pubDate>Wed, 23 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-23-graphql-server/</guid><description>楔子 GraphQL Server 的基本架構大概就幾個主要的元件:
types 資料結構定義 Server 伺服服務 resolver 資料整理用 模版的東西就拿來改比較快，畢竟自已搞定也要很有愛。
codesandbox
市面上常用的大概就 apollor server，要自已寫 types 和 resolvers。
另一個比較好用的有 prisma ，它本身有包含 database ORM 的功用，
也有自動產出 client 段方便套在自已的前端 web。
雜談 其實在 GraphQL 中，最重要的就是 types &amp;amp; resolvers，
這二個的意函在哪裡? types 其實就想像成資料的欄位設定，
resolvers 就想像成取得資料要進行「加減乘除」等等處理的方法。
如果從架構的角度來看
client(Framework) &amp;lt;-&amp;gt; (server &amp;lt;-&amp;gt; database)
在 client 和 server 端為了要彼此能溝通，勢必就要有一個標準的 types 來做依據。
就指的是 client 和 server 端其實都各自要能吃同樣的 types &amp;amp; 解析 query-languages
在 server 端，就因為常常有舊的資料庫問題，那是不是這個 type 同時也能滿足 ORM 的功能?</description></item><item><title>graphql use case</title><link>https://aryung.github.io/posts/2022-03-21-graphql-intro/</link><pubDate>Mon, 21 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-21-graphql-intro/</guid><description>楔子 一般傳統的 RESTFul API 通常有一個缺點， 就是要設定不同的路由(routes)來當作入口點， 久而久之就會有一堆的路由網址，也不敢去做任何的修正， 誰敢擔責任改了是不是會噴錯， 慢慢的就也放著讓它愈長愈大了，當然後來有些 library 像 swagger 可以幫助自動產生文件， 但也還是需要做些設定，這也慢慢的讓 graphQL 有開始長大的空間。
GraphQL 主要的精神架構為， Server 設定好條件(資料的格式 schema &amp;amp; 路由 routes)，
這時透過查詢語法(Query Language)所帶來的參數，經由 business logic 的轉換(資料 CRUD)再回拋資料。
Server 元件 要架一個 GraphQL Server，思考一下要什麼東西??
就觀念上就要有三個東西 = Server + 資料格式 Schema + 一些數據的處理
Server: 可以用 ExpressJS，Apollo Server.. graphQL server Scehma: 基本上就是一個定義檔，可以用不同語言的格式 type &amp;amp; schema，應該各語言都有一些轉換方式 logic: 通常就會牽涉到「數據」的處理，就會扯到 DB ，就會有一些 ORM 使用(eg. sequelize, typeorm, prisma..等等) server var express = require(&amp;#39;express&amp;#39;) var { graphqlHTTP } = require(&amp;#39;express-graphql&amp;#39;) var { buildSchema } = require(&amp;#39;graphql&amp;#39;) var schema = buildSchema(` type Query { hello: String } `) var root = { hello: () =&amp;gt; &amp;#39;Hello world!</description></item><item><title>如何使用 try catch</title><link>https://aryung.github.io/posts/2022-03-18-fp-trycatch/</link><pubDate>Fri, 18 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-18-fp-trycatch/</guid><description>楔子 寫程式時噴錯誤是蠻常見的，就每發生一個錯誤，再加一個條件去排除錯誤的問題
往往如此， code 就會開始蠻的有點「巢狀」的感覺
if(check) { // 1-level if(check) { // 2-level if(check) { // 3-level } else { // 3-level } } else { // 2-level } } else { // 1-level } 原來的 try-catch 標準的 try-catch 程式長相大概如下， try-catch 主要的功用就是避免程式噴錯跳離
try { // do something } catch (e) { console.log(e.message) } 但也常常有個問題就是錯誤的類型如果不確定，就常常一直補 code 除錯。
所以常常的流程大概就是
包一個 try-catch ，噴錯看 log ，補 if-else 的 bug handling，再重覆 try-catch 的 log..
// version 1 function go(x) { try { let len = x.</description></item><item><title>Box 的好用之處</title><link>https://aryung.github.io/posts/2022-03-15-fp-box/</link><pubDate>Tue, 15 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-15-fp-box/</guid><description>楔子 程式碼是拿來使用的，今天就來分享一些小工具來幫助寫 code ，這些東西算是函數式編程的入門吧，用久了才會比較有感，今天就當來練練手。
先上個常用的 tool box
const pipe = (...fns) =&amp;gt; x =&amp;gt; fns.reduce((y, f) =&amp;gt; f(y), x) const I = x =&amp;gt; x const Box = x =&amp;gt; ({ chain: f =&amp;gt; f(x), map: f =&amp;gt; Box(f(x)), fold: f =&amp;gt; f(x), inspect: () =&amp;gt; `Box(${x})` }) const Right = x =&amp;gt; ({ chain : f =&amp;gt; f(x), map : f =&amp;gt; Right(f(x)), fold : (f, g) =&amp;gt; g(x), inspect : () =&amp;gt; `Right(${x})` }) const Left = x =&amp;gt; ({ chain : f =&amp;gt; Left(x), map : f =&amp;gt; Left(x), fold : (f, g) =&amp;gt; f(x), inspect : () =&amp;gt; `Left(${x})` }) const fromNullable = x =&amp;gt; (x === null || x === undefined || x.</description></item><item><title>Promise 新手常花時間的坑</title><link>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</link><pubDate>Sun, 13 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-13-promise-codding-bug-to-newbie/</guid><description>楔子 最近有些小夥伴在彼此討論時，常常出現一些不太知道原因，但改一改就好了，就隨手做一下筆記也方便提醒自已。
狀況一: 分不清楚有沒有回傳值 functo go1 () { return 1 } // 有回傳值 functin go2 () { console.log(3) } // 無回傳值 const go3 = () =&amp;gt; 2 const go4 = () =&amp;gt; { console.log(4) } // 無回傳值 function addOne (x) { return x } const go5 = () =&amp;gt; addOne(3) const go6 = () =&amp;gt; { 7 } const go7 = (x) =&amp;gt; ({x}) 從上面的問題來看，最直覺的就是要有 return 字眼就是代表有回傳值，所以 go1 go2 很容易判斷。</description></item><item><title>Hight Order Function &amp; Callback Function</title><link>https://aryung.github.io/posts/2022-03-10-high-order-function/</link><pubDate>Thu, 10 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-10-high-order-function/</guid><description>楔子 最典型的使用案例是 jQuery 時代，標準的 jQuery 格式大概就長的像下面這樣的格式
// jQuery === $ var hiddenBox = $(&amp;#34;#banner-message&amp;#34;) jQuery(&amp;#34;#button-container button&amp;#34;).on(&amp;#34;click&amp;#34;, function(event) { hiddenBox.show() }) 通常簡化來看就是 $(DOMelement, clickFunction)，而 clickFunction 的長相像就也是像
function (event) { // event handling } 如果是把這種格式轉換一下，大概有幾個注意的要點:
參數可以是一個函數 函數以一個參數為佳 function add (x,y) { return x + y } function addFive (x, referenceCallback) { return referenceCallback(x) } addFive(10, add) // 標準化 function highOrderFunction (x, callback) { return callback(x) } 蠻多的 js 的函數也都採用這樣的 coding style。</description></item><item><title>React 設計模式: Compound Components</title><link>https://aryung.github.io/posts/2022-03-10-react-patten-compond-component/</link><pubDate>Thu, 10 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-10-react-patten-compond-component/</guid><description>楔子 摘錄 Kent 的 React Advance Pattern: Compond Components
這個設計模式有什特殊的點?
如果要做一個切換的鈕的元件，大概就會用一個變數來判斷要如何切換?
function App() { const [on, setOn] = React.useState(false) return ( &amp;lt;div&amp;gt; { on ? &amp;lt;div&amp;gt;The button is on&amp;lt;/div&amp;gt; : null } { on ? null : &amp;lt;div&amp;gt;The button is off&amp;lt;/div&amp;gt; } &amp;lt;/div&amp;gt; ) } 這樣的 code 就有點醜，那有沒有可能性把 code 長成這樣 ?
function App() { return ( &amp;lt;div&amp;gt; &amp;lt;Toggle&amp;gt; &amp;lt;ToggleOn&amp;gt;The button is on&amp;lt;/ToggleOn&amp;gt; &amp;lt;ToggleOff&amp;gt;The button is off&amp;lt;/ToggleOff&amp;gt; &amp;lt;ToggleButton /&amp;gt; &amp;lt;/Toggle&amp;gt; &amp;lt;/div&amp;gt; ) } 來完成 Toogle ToogleOn ToogleOff 這三個元件的寫法呢?</description></item><item><title>取得所有的組合再求結果</title><link>https://aryung.github.io/posts/2022-03-09-combination/</link><pubDate>Wed, 09 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-09-combination/</guid><description>使用情境 資料中任二組(或以上)符合某個條件
例如: 想找 [1,2,3,4,5] 任二個值「大於」3有哪些情況
二組資料的「所有組合」想找符合條件的結果
例如: [1,2,3,4] 和 [7,8.9] 的組合中那個「乘」大於 10
上面的情況在整理資料中蠻常發現的，所以手上有這個函數是蠻方便的，也不太需要自已去造輪子刻，拿來用就好了。
這種會分二種情況:第一種是自已資料的展開，第二種是給二個資料組合展開。
Combination const choose = (n, xs) =&amp;gt; n &amp;lt; 1 || n &amp;gt; xs .length ? [] : n == 1 ? [...xs .map (x =&amp;gt; [x])] : [ ...choose (n - 1, xs .slice (1)) .map (ys =&amp;gt; [xs [0], ...ys]), ...choose (n , xs .slice (1)) ] const getCombs = (min, max, xs) =&amp;gt; xs .</description></item><item><title>JS Prototype by Tyler McGinnis</title><link>https://aryung.github.io/posts/2022-03-08-uidot-prototype/</link><pubDate>Tue, 08 Mar 2022 21:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-uidot-prototype/</guid><description>楔子 Tyler 講的 prototype 的觀念蠻清楚 &amp;amp; 簡單的，稍做一下記錄 Tyler McGinnis javascript
prototype Prototype is a property of a function that point to an object when function is created.
用下面的例子就可以來解釋上面的句子
function imAFunction () {} imAFunction.prototype // {constructor: f} 把共用的 Method 放在一起包裝在一個 Object 內
// 共用的 method const animalMethods() { eat () {}, sleep () {}, play () {} } function Animal (name, energy) { let animal = Object.crete(animalMethods) animal.name = name animal.</description></item><item><title>如何在 useEffect 內使用 async function</title><link>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</link><pubDate>Tue, 08 Mar 2022 20:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-react-async-useeffect/</guid><description>使用情境 一開始的 API 呼叫把值塞進 React 搜尋 autocomplete 前端一開始開啟都會有呼叫 API 情境的狀況發生，比較基本的方式使用大概會長這樣子。
const Users = () =&amp;gt; { const [users, setUsers] = useState([]) useEffect(() =&amp;gt; { fetchUsers().then((users) =&amp;gt; setUsers(users)) }, []) if (!users) return &amp;lt;div&amp;gt;Loading...&amp;lt;/div&amp;gt; return ( &amp;lt;ul&amp;gt; {users.map((user) =&amp;gt; ( &amp;lt;li&amp;gt;{user.name}&amp;lt;/li&amp;gt; ))} &amp;lt;/ul&amp;gt; ) } 那如果要使用 async/await 呢?
很直覺的會這樣寫
// 直接在 useEffect 內使用 async useEffect(async () =&amp;gt; { const users = await fetchUsers() setUsers(users) }, []) 但會有一個情況發生，還記的 useEffect 有一個 cleanup function 嗎?</description></item><item><title>JS 原型說明 by Dan Abramov</title><link>https://aryung.github.io/posts/2022-03-08-justjavascript-prototype/</link><pubDate>Tue, 08 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-08-justjavascript-prototype/</guid><description>楔子 不同的大神針對 JS 有不同的說明講解，來看一下 Redux 作者的說明。
Dan Abramov 有一個 justjavascrpt prototype 其實把觀念寫的蠻好的。
這篇文章是其中一個 prototype 的內容摘錄如下:
先有一個觀念就是 a = '123' 中 a 是變數(variable)， 123 是值(value)
// teeth 是 variable // 32 是值 let human = { teeth: 32 } let gwen = { age: 19 } human 和 gwen 是一個 Object，他把屬性直接連到 值
// gwen 沒有 teeth 屬性 console.log(gwen.teeth) // undefined let human = { teeth: 32 } 如果當用 __proto__ 在 Object 裡面，=的右邊是一個變數，這是就是去找這個變數的 reference 在哪?</description></item><item><title>Neo4j: 圖資料庫</title><link>https://aryung.github.io/posts/2022-03-05-graph-database/</link><pubDate>Sat, 05 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-05-graph-database/</guid><description>楔子 平常使用的最多的應該是 MySQL 了，但通常不同的資料庫有它的使用情境。
簡單分就是有 SQL 和 NoSQL 系列，就二分法的方式處理。
各種資料庫都有它的好用的地方，像 NoSQL 比較有名的就 Redis (它有硬碟版 SSDB)
資料的結構常常會依據使用情境不同有所適合的資料庫。
今天來分享所謂的「圖型」資料庫，資料庫一開始比較需要掌握的就是「設計的理念」
最具代表性的就是 Neo4j
先來看一下它查詢的語法就比較容易理解他的概念。
MATCH (n {name: &amp;#39;John&amp;#39;})-[:FRIEND]-(friend) WITH n, count(friend) AS friendsCount WHERE friendsCount &amp;gt; 3 RETURN n, friendsCount 其實可以「感覺」的出來就是用「node」和「relationship」來做為查詢的方式，
在每個「node」的上面有屬性，而不同的屬性可以有「條件」來進行過濾。
node 用 () 來標記，關係用 [] 來表示
特徵 就自然有人問，那這個資料庫的好處在哪?
大家覺的「圖」這種的設計，比較常出現在哪? 答案就是 社群 ，它就是點和線的連結而以。
當有這個想法後，例如我好朋友的朋友有哪些?
MATCH (i {name: &amp;#39;me&amp;#39;})-[:FRIEND]-(f1:friend)-[:FRIEND]-(f2:friend) RETURN n, f1, f2 i = 我; f1 = 我朋友; f2 = 我朋友的朋友
如果想像用 RDBMS，就要用二層 select 來處理(或使用 sub-query)，</description></item><item><title>函數式編程 Functor 的運用</title><link>https://aryung.github.io/posts/2022-03-04-functional-programming-in-js-box/</link><pubDate>Fri, 04 Mar 2022 18:29:06 +0800</pubDate><guid>https://aryung.github.io/posts/2022-03-04-functional-programming-in-js-box/</guid><description>特徵 可以把函數當參數使用 可以使用 compose(反向) 或 pipe(正向) 的串連方式 // 建立一個標準的函數 let func = f = x =&amp;gt; f(x) let addOne = x =&amp;gt; x + 1 let ff = func(addOne) // f = addOne ff(1) // 1+1 pipe 就像一個水管一樣串接不同的 function
const pipe = (...fns) =&amp;gt; x =&amp;gt; fns.reduce((y, f) =&amp;gt; f(y), x) pipe(x =&amp;gt; x + 1, x =&amp;gt; x + 2)(3) 練習看看 有了上面的東西，如何使用?
如果有興趣可以去看看 Dr.Boolean 的一些影片，擷取一些常用的工具來做使用。
const pipe = (.</description></item></channel></rss>